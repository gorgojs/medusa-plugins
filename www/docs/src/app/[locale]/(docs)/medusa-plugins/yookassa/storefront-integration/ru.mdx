# Интеграция YooKassa с витриной (Storefront)

Для интеграции платёжного провайдера YooKassa с storefront на Next.js начните с добавления необходимых UI-компонентов. Таким образом провайдер будет отображаться на странице оформления заказа наряду с другими доступными методами оплаты.

Когда пользователь выбирает YooKassa, витрина должна вызвать метод `initiatePayment` с нужными параметрами. Это создаст платёжную сессию через API YooKassa и подготовит покупателя к перенаправлению. После этого кнопка *Place Order* должна отправить пользователя на страницу оплаты YooKassa, где он сможет выбрать предпочтительный способ оплаты.

После завершения оплаты YooKassa одновременно отправит вебхук и перенаправит покупателя обратно в витрину. То событие, которое придёт первым, завершит корзину и создаст новый заказ в Medusa.

## 1. Конфигурация платежного провайдера

Чтобы сделать YooKassa доступным в качестве способа оплаты на странице оформления заказа витрины магазина, необходимо добавить её конфигурацию в маппинг платёжных провайдеров в файле с константами вашего storefront. Этот маппинг определяет как каждый провайдер отображается в интерфейсе.

Откройте [`src/lib/constants.tsx`](https://github.com/sergkoudi/medusa-payment-yookassa/blob/bce2e01d8932b3c09b66a3a1b06aa1d5c4cfc445/examples/medusa-storefront/src/lib/constants.tsx#L33-L36) и добавьте следующий код:

![Структура проекта storefront Medusa после обновления файла с константами](https://github.com/user-attachments/assets/0aee001e-958f-40c6-b329-618e318ff019)

```ts
export const paymentInfoMap: Record<
  string,
  { title: string; icon: React.ReactNode }
> = {
  // ... другие провайдеры
  pp_yookassa_yookassa: {
    title: "YooKassa",
    icon: <CreditCard />,
  }
}

// Вспомогательная функция для проверки, является ли провайдер YooKassa
export const isYookassa = (providerId?: string) => {
  return providerId?.startsWith("pp_yookassa")
}
```

Вы расширяете объект `paymentInfoMap`, добавляя в него запись `pp_yookassa_yookassa`. Эта запись определяет заголовок и иконку, которые будут отображаться для YooKassa на странице оформления заказа.

Вспомогательная функция `isYookassa` проверяет, принадлежит ли переданный `providerId` к YooKassa.
Это используется при рендеринге UI-компонентов, специфичных для конкретного провайдера.

## 2. Настройки Cookie

При подключении YooKassa настройте политику cookie так, чтобы поддерживались междоменные редиректы. Это нужно для сохранения платёжной сессии при возврате пользователя в магазин.

Откройте [`src/lib/data/cookies.ts`](https://github.com/sergkoudi/medusa-payment-yookassa/blob/bce2e01d8932b3c09b66a3a1b06aa1d5c4cfc445/examples/medusa-storefront/src/lib/data/cookies.ts#L75) и обновите конфигурацию файлов cookie следующим образом:

![Структура проекта storefront Medusa после обновления файлов cookie](https://github.com/user-attachments/assets/4274d249-6994-4d9f-b4b6-98f2016f0e9f)

```ts
export const setCartId = async (cartId: string) => {
  cookies.set("_medusa_cart_id", cartId, {
    // ... другие настройки cookie
    sameSite: "lax", // Переключено с режима «Strict» для междоменных редиректов
  })
}
```

Эта вспомогательная функция сохраняет идентификатор корзины в cookie с именем `_medusa_cart_id`.

Опция `sameSite` установлена в значение `lax` вместо `strict`. Это изменение гарантирует, что cookie будет отправляться при кросс-доменных запросах во время процесса редиректа через YooKassa, предотвращая потерю платёжной сессии.

## 3. Инициализация платёжной сессии

Чтобы перенаправить покупателя в YooKassa, платёжная сессия должна быть корректно инициализирована с необходимыми параметрами, включая return URL после оплаты и корзину для формирования онлайн-чеков.

Откройте [`src/modules/checkout/components/payment/index.tsx`](https://github.com/sergkoudi/medusa-payment-yookassa/blob/main/examples/medusa-storefront/src/modules/checkout/components/payment/index.tsx#L87-L96) и обновите логику инициализации платежа, включив в нее данные корзины и URL возврата для YooKassa:

![Directory structure in the Medusa Storefront after updating the file for payment component](https://github.com/user-attachments/assets/5c4dfcf9-57e7-48f6-956c-0e0a91ec6c8f)

```ts
await initiatePaymentSession(cart, {
  provider_id: selectedPaymentMethod,
  data: {
    confirmation: {
      type: "redirect",
      return_url: `${getBaseURL()}/api/capture-payment/${cart?.id}?country_code=${countryCode}`
    },
    cart: cart
  }
})
```

При инициировании платёжной сессии для YooKassa передайте объект `confirmation` с `type: "redirect"` и `return_url`. Позже YooKassa предоставит `confirmation_url`, на которое клиент должен быть перенаправлен.

Параметр `return_url` указывает на конечную точку захвата вашего магазина и используется как для успешных, так и для неудачных попыток оплаты.

Объект `cart` включается в данные инициализации для формирования чека в соответствии с Федеральным законом № 54.

## 4. Компонент кнопки оплаты

В storefront для каждого платёжного провайдера необходим отдельный компонент кнопки оплаты. Он отвечает за обработку оформления заказа после подтверждения пользователем и, используя данные платёжного сеанса, перенаправляет его на страницу оплаты YooKassa.

Откройте [`src/modules/checkout/components/payment-button/index.tsx`](https://github.com/sergkoudi/medusa-payment-yookassa/blob/bce2e01d8932b3c09b66a3a1b06aa1d5c4cfc445/examples/medusa-storefront/src/modules/checkout/components/payment-button/index.tsx#L205-L247) и добавьте следующий код:

![Структура проекта storefront Medusa после обновления файла для компонента кнопки оплаты](https://github.com/user-attachments/assets/4b76ee52-747f-452e-9160-6365f742e33e)

```ts
const PaymentButton: React.FC<PaymentButtonProps> = ({
  cart,
  "data-testid": dataTestId,
}) => {
  // ...
  switch (true) {
    // ... другие проверки
    case isYookassa(paymentSession?.provider_id):
      return (
        <YookassaPaymentButton
          notReady={notReady}
          cart={cart}
          data-testid={dataTestId}
        />
      )
    default:
      return <Button disabled>Select a payment method</Button>
  }
}

// ... другие компоненты кнопок оплаты

const YookassaPaymentButton = ({
  cart,
  notReady
}: {
  cart: HttpTypes.StoreCart
  notReady: boolean
  "data-testid"?: string
}) => {
  const [submitting, setSubmitting] = useState(false)
  const [errorMessage, setErrorMessage] = useState<string | null>(null)
  const router = useRouter()

  const paymentSession = cart.payment_collection?.payment_sessions?.find(
    session => session.provider_id === "pp_yookassa_yookassa"
  )

  const handlePayment = () => {
    setSubmitting(true)

    const confirmation = paymentSession?.data?.confirmation as IConfirmation
    if (confirmation?.confirmation_url) {
      router.push(confirmation.confirmation_url)
    }
  }

  return (
    <>
      <Button
        disabled={notReady}
        isLoading={submitting}
        onClick={handlePayment}
        size="large"
        data-testid="submit-order-button"
      >
        Place an order and pay
      </Button>
      <ErrorMessage
        error={errorMessage}
        data-testid="manual-payment-error-message"
      />
    </>
  )
}
```

Этот компонент находит `payment_session` YooKassa в активной корзине и извлекает значение `data.confirmation.confirmation_url`.  Когда пользователь нажимает кнопку *Place an order*, он перенаправляется на этот URL для завершения оплаты на странице YooKassa.

Если `confirmation_url` отсутствует, компонент отображает сообщение об ошибке вместо продолжения процесса.   Состояние `isLoading` обеспечивает визуальную обратную связь во время подготовки перенаправления.

Родительский компонент `PaymentButton` использует функцию `isYookassa`, чтобы определить, нужно ли отобразить `YookassaPaymentButton` для текущей сессии; в противном случае показывается неактивная кнопка *Select a payment method*.

## 5. API-роут подтверждения платежа

После того как покупатель завершает оплату на странице YooKassa, он перенаправляется обратно на витрину магазина. Необходимо создать API-роут, который обработает этот callback, проверит статус платежа и завершит корзину.

Создайте файл [`src/app/api/capture-payment/[cartId]/route.ts`](https://github.com/sergkoudi/medusa-payment-yookassa/blob/main/examples/medusa-storefront/src/app/api/capture-payment/%5BcartId%5D/route.ts)  со следующим содержимым:

![Структура проекта storefront Medusa после создания файла для API route](https://github.com/user-attachments/assets/89ac89de-62ad-4b6c-af61-ab6299587dbf)

```ts
import { NextRequest, NextResponse } from "next/server"
import { revalidateTag } from "next/cache"
import {
  getCacheTag,
  getAuthHeaders,
  removeCartId
} from "@lib/data/cookies"
import { sdk } from "@lib/config"
import { placeOrder } from "@lib/data/cart"

type Params = Promise<{ cartId: string }>

export async function GET(req: NextRequest, { params }: { params: Params }) {
  const { cartId } = await params
  const { origin, searchParams } = req.nextUrl

  const countryCode = searchParams.get("country_code") || ""
  const headers = { ...(await getAuthHeaders()) }

  // Retrieve fresh cart values
  const cartCacheTag = await getCacheTag("carts")
  revalidateTag(cartCacheTag)
  const { cart } = await sdk.store.cart.retrieve(cartId, {
    fields: "id, order_link.order_id"
  },
    headers
  )
  if (!cart) {
    return NextResponse.redirect(`${origin}/${countryCode}`)
  }

  const orderId = (cart as unknown as Record<string, any>).order_link?.order_id
  if (!orderId) {
    await placeOrder(cartId)
    // Fail when payment not authorized
    return NextResponse.redirect(
      `${origin}/${countryCode}/checkout?step=review&error=payment_failed`
    )
  }

  const orderCacheTag = await getCacheTag("orders")
  revalidateTag(orderCacheTag)
  removeCartId()
  return NextResponse.redirect(
    `${origin}/${countryCode}/order/${orderId}/confirmed`
  )
}
```

Этот API-роут обрабатывает редирект от YooKassa после попытки оплаты. Он получает актуальное состояние корзины, чтобы убедиться, что все изменения, внесённые во время оплаты, были отражены.

Если в корзине нет связанного идентификатора заказа, обработчик роута пытается оформить заказ. В случае успеха покупатель перенаправляется на страницу подтверждения заказа. Если же при обработке корзины возникла ошибка, покупатель возвращается на страницу оформления заказа с указанием ошибки и может повторить процесс оплаты заказа.

Когда оплата проходит успешно, роут повторно валидирует кэшированные данные корзины и заказа, удаляет cookie корзины и перенаправляет покупателя на страницу подтверждения заказа. Это гарантирует корректное завершение платёжного процесса и сохранение актуальных данных в storefront.

## Пример

Вы можете ознакомиться с изменениями, внесенными в стартовый шаблон [Medusa Next.js Starter Template](https://github.com/medusajs/nextjs-starter-medusa) в директории [`examples/medusa-storefront`](https://github.com/sergkoudi/medusa-payment-yookassa/tree/main/examples/medusa-storefront).

Полный код интеграции можно посмотреть в разделе [comparison page](https://github.com/sergkoudi/medusa-payment-yookassa/compare/v0.0.3...main), откройте вкладку `Files changed` и изучите различия в каталоге `examples/medusa-storefront`. Или запустите `diff` в терминале:

```bash
git clone https://github.com/sergkoudi/medusa-payment-yookassa
cd medusa-payment-yookassa
git diff v0.0.3...main -- examples/medusa-storefront
```
