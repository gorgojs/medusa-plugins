/* tslint:disable */
/* eslint-disable */
/**
 * ApiShip
 * **Документация единого API логистических компаний**  **Дополнительная документация: [docs.apiship.ru](https://docs.apiship.ru)**  **Подробнее об ApiShip на [apiship.ru](https://apiship.ru) или задайте вопрос на [info@apiship.ru](mailto:info@apiship.ru  )** 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@apiship.ru
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AddOrderCall200Response {
    'orders'?: Array<B2cplOrderCallResponse>;
}
export interface AdditionalServiceObject {
    /**
     * Идентификатор службы доставки
     */
    'providerKey'?: string;
    /**
     * Название услуги
     */
    'name'?: string;
    /**
     * Ключ в extraParams
     */
    'extraParamName'?: string;
    /**
     * Тип значения для extraParams:  * `bool` - булев тип значения, принимает *true, false, 0, 1*  * `string` - строковый тип значения, принимает *\"\", \"qwerty123\"*  * `int` - целочисленный тип значения, принимает *1, 2, 3, 4, 5, 6*  * `float` - число с плавающей точкой, принимает *999.123, 6343.7898* 
     */
    'valueType'?: AdditionalServiceObjectValueTypeEnum;
    /**
     * Описание типа значения для extraParams
     */
    'valueDescription'?: string;
    /**
     * Описание услуги
     */
    'description'?: string;
}

export const AdditionalServiceObjectValueTypeEnum = {
    Bool: 'bool',
    String: 'string',
    Int: 'int',
    Float: 'float'
} as const;

export type AdditionalServiceObjectValueTypeEnum = typeof AdditionalServiceObjectValueTypeEnum[keyof typeof AdditionalServiceObjectValueTypeEnum];

export interface Address {
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode'?: string;
    /**
     * Почтовый индекс
     */
    'postIndex'?: string;
    /**
     * Область или республика или край
     */
    'region'?: string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Город или населенный пункт
     */
    'city'?: string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Населённый пункт
     */
    'community'?: string | null;
    /**
     * ID населённого пункта в базе ФИАС
     */
    'communityGuid'?: string | null;
    /**
     * Улица
     */
    'street'?: string;
    /**
     * Дом
     */
    'house'?: string;
    /**
     * Строение/Корпус
     */
    'block'?: string;
    /**
     * Офис/Квартира
     */
    'office'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Полный адрес одной строкой. При заполнении этого поля остальные можно не заполнять, кроме countryCode
     */
    'addressString'?: string;
}
export interface B2cplCityObject {
    'id'?: number;
    /**
     * Регион/область
     */
    'region'?: string;
    /**
     * Населенный пункт
     */
    'residence'?: string;
    /**
     * Начало диапазона почтовых индексов
     */
    'zipFirst'?: string;
    /**
     * Конец диапазона почтовых индексов
     */
    'zipLast'?: string;
    /**
     * Длительность магистральной перевозки между Москвой и городом получателем в рабочих днях
     */
    'transportDays'?: number;
    /**
     * Возможность курьерской доставки в этом диапазоне
     */
    'flagCourier'?: string;
    /**
     * Возможность ПВЗ доставки в этом диапазоне
     */
    'flagPvz'?: string;
    /**
     * Возможность доставки авиа. 0 – нет авиа доставки, 1 – только авиа доставка, 2 – возможна как наземная, так и авиа доставки
     */
    'flagAvia'?: string;
    /**
     * ФИАС для города/села/поселка
     */
    'cityGuid'?: string;
}
export interface B2cplOrderCallData {
    /**
     * Телефон клиента
     */
    'phone': string;
    /**
     * ФИО клиента
     */
    'name': string;
    /**
     * Номер заказа
     */
    'orderId': string;
    /**
     * Источник заказа
     */
    'source'?: string;
    /**
     * Комментарий к заказу
     */
    'comment'?: string;
}
export interface B2cplOrderCallRequest {
    'orders': Array<B2cplOrderCallData>;
}
export interface B2cplOrderCallResponse {
    /**
     * Номер заказа
     */
    'orderCode'?: string;
    /**
     * Указывает успешно ли загружен телефон
     */
    'success'?: boolean;
    /**
     * Сообщение от сервиса
     */
    'message'?: string;
}
export interface BillingBalanceGet200Response {
    'calculations'?: number;
    'freeCalculations'?: number;
    'money'?: string;
}
export interface BoxberryCityObject {
    'id'?: string;
    /**
     * Код города
     */
    'code'?: string;
    /**
     * ФИАС Города
     */
    'cityGuid'?: string;
    /**
     * Регион
     */
    'region'?: string;
    /**
     * Район
     */
    'district'?: string;
    /**
     * Индексы
     */
    'courierZips'?: Array<string>;
    /**
     * Прием писем и посылок от физ. лиц (0/1)
     */
    'receptionLaP'?: string;
    /**
     * Выдача писем и посылок физ. лиц (0/1)
     */
    'deliveryLaP'?: string;
    /**
     * Прием заказов от ИМ на пунктах выдачи (0/1)
     */
    'reception'?: string;
    /**
     * Наличие пунктов выдачи заказов в городе (0/1)
     */
    'pickupPoint'?: string;
    /**
     * Наличие курьерской доставки в городе
     */
    'courierDelivery'?: string;
    /**
     * Прием международных возвратов (0/1)
     */
    'foreignReceptionReturns'?: string;
    /**
     * Наличие терминала в городе (0/1)
     */
    'terminal'?: string;
    /**
     * Наличие курьерского забора (0/1)
     */
    'courierReception'?: string;
}
export interface BoxberryWarehouseCodePutRequest {
    /**
     * Наименование склада
     */
    'name': string;
    /**
     * Почтовый индекс
     */
    'zip'?: string;
    /**
     * Адрес склада
     */
    'address'?: string;
    /**
     * Контактное лицо
     */
    'contactPerson'?: string;
    /**
     * Контактный телефон
     */
    'contactPhone'?: string;
    /**
     * Код пункта приема Боксберри
     */
    'receptionPointCode': string;
    /**
     * ID подключения к СД
     */
    'providerConnectId'?: string;
}
export interface BoxberryWarehousePostRequest {
    /**
     * Уникальный код склада
     */
    'code': string;
    /**
     * Наименование склада
     */
    'name': string;
    /**
     * Почтовый индекс
     */
    'zip'?: string;
    /**
     * Адрес склада
     */
    'address'?: string;
    /**
     * Контактное лицо
     */
    'contactPerson'?: string;
    /**
     * Контактный телефон
     */
    'contactPhone'?: string;
    /**
     * Код пункта приема Боксберри
     */
    'receptionPointCode': string;
    /**
     * ID подключения к СД
     */
    'providerConnectId'?: string;
}
export interface CalculatorDirection {
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode': string;
    /**
     * Почтовый индекс
     */
    'index'?: string;
    /**
     * Полный почтовый адрес. Если заполнен, то считается приоритетным, если не указан cityGuid. <br /> *Обязателен, если не указаны cityGuid или city.
     */
    'addressString': string;
    /**
     * Регион/Край/Область
     */
    'region'?: string;
    /**
     * Название города (обязательно если не заполнен cityGuid). <br /> *Обязателен, если не указаны cityGuid или addressString.
     */
    'city': string;
    /**
     * ФИАС код города\\поселения в базе fias.nalog.ru (обязательно, если не заполнен city). <br /> *Обязателен, если не указаны city или addressString.
     */
    'cityGuid': string;
    /**
     * Широта. Обязательно указывайте, если это доставка через такси, например, Яндекс.Доставка и д.р.
     */
    'lat'?: number;
    /**
     * Долгота. Обязательно указывайте, если это доставка через такси, например, Яндекс.Доставка и д.р.
     */
    'lng'?: number;
}
export interface CalculatorIntervalsRequest {
    'to': CalculatorDirection;
    'from': CalculatorDirection;
    /**
     * Сумма наложенного платежа
     */
    'codCost'?: number;
    /**
     * Дата приёма груза
     */
    'pickupDate'?: string;
    /**
     * Дата доставки груза
     */
    'deliveryDate'?: string;
    /**
     * [Типы забора /lists/pickupTypes](#/lists/pickupTypes). Если не переданы, то рассчитываются тарифы по всем типам (Забор груза курьером, Сдача груза на ПВЗ)
     */
    'pickupTypes'?: Array<number>;
    /**
     * Массив ключей служб доставки. Если не передавать, то рассчитает тарифы всех подключенных к аккаунту служб доставки
     */
    'providerKeys'?: Array<string>;
    /**
     * Дополнительные параметры. Например. можно рассчитать DPD по какому-то определенному подключению (договору), передав dpd.providerConnectId = id из [/connections/getListConnections](#/connections/getListConnections)  Передавать как {\"<ключ\\_службы\\_доставки>.<код_параметра>\": \"<значение>\"}
     */
    'extraParams'?: { [key: string]: string; };
    /**
     * Тарифы, для которых необходимо произвести расчёт
     */
    'tariffIds'?: Array<number>;
}
export interface CalculatorIntervalsResponse {
    'deliveryToDoor'?: Array<CalculatorIntervalsResponseDeliveryToDoorInner>;
}
export interface CalculatorIntervalsResponseDeliveryToDoorInner {
    'providerKey'?: string;
    'tariffs'?: Array<CalculatorIntervalsTariffResult>;
}
export interface CalculatorIntervalsTariffResult {
    /**
     * ID тарифа в службе доставки
     */
    'tariffProviderId'?: string;
    /**
     * ID тарифа в ApiShip
     */
    'tariffId'?: number;
    /**
     * Название тарифа
     */
    'tariffName'?: string;
    /**
     * Типы забора (см. /lists/pickupTypes), если не переданы берутся оба типа
     */
    'pickupTypes'?: Array<number>;
    /**
     * Типы доставки (см. /lists/deliveryTypes), если не переданы берутся оба типа
     */
    'deliveryTypes'?: Array<number>;
    'toIntervals'?: Array<DeliveryInterval>;
}
export interface CalculatorPlace {
    'height'?: any;
    'length'?: any;
    'width'?: any;
    /**
     * Вес единицы товара в граммах
     */
    'weight'?: number;
}
export interface CalculatorRequest {
    /**
     * Автоматически передокладывается в places[0].height
     * @deprecated
     */
    'height'?: any;
    /**
     * Автоматически передокладывается в places[0].length
     * @deprecated
     */
    'length'?: any;
    /**
     * Автоматически передокладывается в places[0].width
     * @deprecated
     */
    'width'?: any;
    /**
     * Автоматически передокладывается в places[0].weight
     * @deprecated
     */
    'weight'?: any;
    'to': CalculatorDirection;
    'from': CalculatorDirection;
    /**
     * Места. Калькуляция многоместных заказов.. В случае когда СД не поддерживает многоместную калькуляцию, вес суммируется, а габариты всех коробок складываются в высоту и берется макс. длина и ширина, то есть коробки ставятся друг на друга пирамидой и передаются в СД для расчета
     */
    'places': Array<CalculatorPlace>;
    /**
     * Дата приёма груза (не обязательно, по умолчания берется текущая дата)
     */
    'pickupDate'?: string;
    /**
     * [Типы забора /lists/pickupTypes](#/lists/pickupTypes). Если не переданы, то рассчитываются тарифы по всем типам (Забор груза курьером, Сдача груза на ПВЗ)
     */
    'pickupTypes'?: Array<number>;
    /**
     * [Типы доставки /lists/deliveryTypes](#/lists/deliveryTypes). Если не переданы, то рассчитываются тарифы по всем типам (Доставка Курьером, Самовывоз из ПВЗ)
     */
    'deliveryTypes'?: Array<number>;
    /**
     * Массив ключей служб доставки. Если не передавать, то рассчитает тарифы всех подключенных к аккаунту служб доставки
     */
    'providerKeys'?: Array<string>;
    /**
     * Оценочная стоимость (в рублях)
     */
    'assessedCost'?: number;
    /**
     * Сумма наложенного платежа
     */
    'codCost'?: number;
    /**
     * Суммировать ли к итоговой стоимости все сборы СД (страховка и комиссия за НП)
     */
    'includeFees'?: boolean;
    /**
     * Время ожидания ответа (мс.) от провайдера, результаты по провайдерам, которые не успели в указанное время выдаваться не будут
     */
    'timeout'?: number;
    /**
     * Пропускает применение правил редактора тарифов. Полезно, если надо проверить корректность применения правил
     */
    'skipTariffRules'?: boolean;
    /**
     * Дополнительные параметры. Например. можно рассчитать DPD по какому-то определенному подключению (договору), передав dpd.providerConnectId = id из [/connections/getListConnections](#/connections/getListConnections)  Передавать как {\"<ключ\\_службы\\_доставки>.<код_параметра>\": \"<значение>\"}
     */
    'extraParams'?: { [key: string]: string; };
    /**
     * Промокод. В редакторе тарифов можно указать промокод, по которому можно изменять тарифы, например, скидку на стоимость доставки.
     */
    'promoCode'?: string;
    /**
     * Пользовательское поле. В это поле можно передать, например, название сайта и по нему строить правила в редакторе сайтов.
     */
    'customCode'?: string;
    /**
     * Тарифы, для которых необходимо произвести расчёт
     */
    'tariffIds'?: Array<number>;
    /**
     * Идентификатор ПВЗ от которого вести расчет
     */
    'pointInId'?: number;
    /**
     * Идентификатор ПВЗ до которого вести расчет
     */
    'pointOutId'?: number;
}
export interface CalculatorToDoorResult {
    'providerKey'?: string;
    'tariffs'?: Array<CalculatorToDoorResultTariffsInner>;
}
export interface CalculatorToDoorResultTariffsInner {
    /**
     * ID тарифа в службе доставки
     */
    'tariffProviderId'?: string;
    /**
     * ID тарифа в ApiShip
     */
    'tariffId'?: number;
    /**
     * Название тарифа
     */
    'tariffName'?: string;
    /**
     * Типы забора (см. /lists/pickupTypes), если не переданы берутся оба типа
     */
    'pickupTypes'?: Array<number>;
    /**
     * Типы доставки (см. /lists/deliveryTypes), если не переданы берутся оба типа
     */
    'deliveryTypes'?: Array<number>;
    /**
     * Стоимость тарифа
     */
    'deliveryCost'?: number;
    /**
     * Стоимость тарифа до применения правил
     */
    'deliveryCostOriginal'?: number;
    /**
     * Были ли включены сборы СД в общую стоимость (deliveryCost). NULL если невозможно определить
     */
    'feesIncluded'?: boolean;
    /**
     * Сумма страховых сборов. NULL если невозможно определить
     */
    'insuranceFee'?: number;
    /**
     * Сумма сборов за наложенный платёж. NULL если невозможно определить
     */
    'cashServiceFee'?: number;
    /**
     * Максимальное кол-во дней доставки
     * @deprecated
     */
    'daysMax'?: number;
    /**
     * Минимальное кол-во дней доставки
     * @deprecated
     */
    'daysMin'?: number;
    /**
     * Максимальное кол-во календарных дней доставки
     */
    'calendarDaysMax'?: number;
    /**
     * Минимальное кол-во календарных дней доставки
     */
    'calendarDaysMin'?: number;
    /**
     * Максимальное кол-во рабочих дней доставки
     */
    'workDaysMax'?: number;
    /**
     * Минимальное кол-во рабочих дней доставки
     */
    'workDaysMin'?: number;
}
export interface CalculatorToPointResult {
    'providerKey'?: string;
    'tariffs'?: Array<CalculatorToPointResultAllOfTariffs>;
}
export interface CalculatorToPointResultAllOfTariffs {
    'deliveryTypes'?: any;
    /**
     * Массив ID доступных ПВЗ для каждого из тарифов
     */
    'pointIds'?: Array<number>;
}
export interface CancelCourierCallResponse {
    /**
     * Номер заявки
     */
    'id'?: number;
    /**
     * Дата отмены заявки
     */
    'canceled'?: string;
}
export interface CancelOrderResponse {
    /**
     * Номер заказа
     */
    'orderId'?: number;
    /**
     * Дата отмены заказа
     */
    'canceled'?: string;
}
export interface CdekCityObject {
    /**
     * Код адресного объекта в ФИАС
     */
    'fiasGuid'?: string;
    /**
     * Полное название города с регионом
     */
    'fullName'?: string;
    /**
     * UUID записи
     */
    'cityUuid'?: string;
    /**
     * Код города по базе СДЭК
     */
    'cdekId'?: number;
    /**
     * Название города из системы СДЭК
     */
    'cityName'?: string;
    /**
     * Название региона
     */
    'oblName'?: string;
    /**
     * Код страны
     */
    'countryCode'?: string;
    /**
     * Ограничение на сумму наложенного платежа
     */
    'codCostLimit'?: string;
}
export interface ColumnMap {
    /**
     * Номер заказа в системе клиента
     */
    'order.clientNumber': string;
    /**
     * Вес всего заказа в граммах
     */
    'order.weight'?: number;
    /**
     * Высота заказа в сантиметрах
     */
    'order.height'?: number;
    /**
     * Длина заказа в сантиметрах
     */
    'order.length'?: number;
    /**
     * Ширина заказа в сантиметрах
     */
    'order.width'?: number;
    /**
     * Код службы доставки
     */
    'order.providerKey'?: string;
    /**
     * ID подключения к СД
     */
    'order.providerConnectId'?: number;
    /**
     * Тип забора груза (1 - от двери клиента; 2 – клиент привозит заказ на склад СД)
     */
    'order.pickupType': number;
    /**
     * Тип доставки (1 - до двери; 2 – до ПВЗ)
     */
    'order.deliveryType': number;
    /**
     * Идентификатор точки забора товара в системе apiship
     */
    'order.pointInId'?: number;
    /**
     * Идентификатор точки выдачи товара в системе apiship
     */
    'order.pointOutId'?: number;
    /**
     * Тариф службы доставки, по которому осуществляется доставка
     */
    'order.tariffId': number;
    /**
     * Начальное время доставки
     */
    'order.deliveryTimeStart'?: string;
    /**
     * Конечное время доставки
     */
    'order.deliveryTimeEnd'?: string;
    /**
     * Оценочная стоимость / сумма страховки (в рублях)
     */
    'cost.assessedCost': number;
    /**
     * Сумма наложенного платежа с учетом НДС (в рублях)
     */
    'cost.codCost': number;
    /**
     * Стоимость доставки с получателя. codCost должен содержать в себе эту сумму.
     */
    'cost.deliveryCost'?: number;
    /**
     * Контактный телефон
     */
    'sender.phone': string;
    /**
     * Название компании
     */
    'sender.companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'sender.contactName': string;
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'sender.countryCode': string;
    /**
     * Область или республика или край
     */
    'sender.region': string;
    /**
     * Город или населенный пункт
     */
    'sender.city': string;
    /**
     * Улица
     */
    'sender.street': string;
    /**
     * Дом
     */
    'sender.house': string;
    /**
     * Строение/Корпус
     */
    'sender.block'?: string;
    /**
     * Офис/Квартира
     */
    'sender.office'?: string;
    /**
     * Контактный email адрес
     */
    'sender.email'?: string;
    /**
     * Адрес одной строкой
     */
    'sender.AddressString'?: string;
    /**
     * Контактный телефон
     */
    'recipient.phone': string;
    /**
     * Название компании
     */
    'recipient.companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'recipient.contactName': string;
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'recipient.countryCode': string;
    /**
     * Область или республика или край
     */
    'recipient.region': string;
    /**
     * Город или населенный пункт
     */
    'recipient.city': string;
    /**
     * Улица
     */
    'recipient.street': string;
    /**
     * Дом
     */
    'recipient.house': string;
    /**
     * Строение/Корпус
     */
    'recipient.block'?: string;
    /**
     * Офис/Квартира
     */
    'recipient.office'?: string;
    /**
     * Контактный email адрес
     */
    'recipient.email'?: string;
    /**
     * Адрес одной строкой
     */
    'recipient.AddressString'?: string;
    /**
     * Наименование товара
     */
    'item.description': string;
    /**
     * Кол-во товара
     */
    'item.quantity': number;
    /**
     * Артикул товара
     */
    'item.articul'?: string;
    /**
     * ШК предмета
     */
    'item.barcode'?: string;
    /**
     * Оценочная стоимость единицы товара в рублях
     */
    'item.assessedCost'?: number;
    /**
     * Наложенная стоимость товара в рублях
     */
    'item.cost'?: number;
    /**
     * Вес единицы товара в граммах
     */
    'item.weight': number;
    /**
     * Высота единицы товара в сантиметрах
     */
    'item.height'?: number;
    /**
     * Длина единицы товара в сантиметрах
     */
    'item.length'?: number;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'item.width'?: number;
    /**
     * Номер места в информационной системе клиента
     */
    'place.placeNumber'?: string;
    /**
     * Штрихкод места
     */
    'place.barcode'?: string;
    /**
     * Высота места в сантиметрах
     */
    'place.height'?: number;
    /**
     * Ширина места в сантиметрах
     */
    'place.width'?: number;
    /**
     * Длина места в сантиметрах
     */
    'place.length'?: number;
    /**
     * Вес места в граммах
     */
    'place.weight'?: number;
    /**
     * Содержимое места
     */
    'place.items'?: Array<Item>;
    /**
     * Дополнительная услуга (вместо звёздочки в названии параметра необходимо подставить название дополнительной услуги)
     */
    'extraParams.*'?: string;
}
export interface ColumnSettings {
    /**
     * Формат даты в таблице
     */
    'dateFormat': string;
    /**
     * Формат ФИО в таблице (true(или 1) - ФИО в разных столбцах; false(или 0) - ФИО в одном столбце)
     */
    'nameFormat': boolean;
    /**
     * Тип расположения данных о товарных вложениях (true - располагаются в строке информации о заказе; false - располагаются под информацией о заказе)
     */
    'itemsNewRow': boolean;
    /**
     * Формат времени в таблице
     */
    'timeFormat': string;
    /**
     * Порядковый номер первой считываемой строки таблицы
     */
    'rowStart'?: number;
    /**
     * Порядковый номер последней считываемой строки таблицы
     */
    'rowEnd'?: number;
}
export interface ConfirmOrderYataxiRequest {
    /**
     * ID заказа
     */
    'orderId': string;
}
export interface ConfirmOrderYataxiResponse {
    /**
     * Идентификатор заявки, полученный на этапе создания заявки
     */
    'id'?: string;
    /**
     * Статус заявки
     */
    'status'?: string;
    /**
     * Версия заявки из запроса
     */
    'version'?: string;
}
export interface Connection {
    'id'?: string;
    /**
     * ID - компании (можно не указывать)
     */
    'companyId'?: string;
    /**
     * Код службы доставки
     */
    'providerKey'?: string;
    /**
     * Название подключения
     */
    'name'?: string;
    /**
     * ИНН вашей организации
     */
    'inn'?: string;
    /**
     * Своя для компании процентная ставка страховки (%) - перекрывает общую для СД
     */
    'insuranceRate'?: number;
    /**
     * Своя для компании процентная ставка кассового обслуживания (%) - перекрывает общую для СД
     */
    'cashServiceRate'?: number;
    /**
     * Данные берутся из метода [/connections/schemas](#/connections/schemas)
     */
    'connectParams'?: { [key: string]: string; };
    /**
     * 0 - никогда не использовать базовое подключение ApiShip; 1 - подключение будет использовать базовое подключение ApiShip, т.е. передавать connectParams не нужно; 2 - будет использовано базовое подключение, если в процессе калькуляции по текущим параметрам подключения возникнет ошибка;
     */
    'isUseBaseConnect'?: number;
    /**
     * Дата создания
     */
    'created'?: string;
    /**
     * Дата обновления
     */
    'updated'?: string;
}
export interface ConnectionSchema {
    'providerKey'?: string;
    'fields'?: Array<ConnectionSchemaFieldsInner>;
}
export interface ConnectionSchemaFieldsInner {
    /**
     * Код поля
     */
    'code'?: string;
    /**
     * Текстовое название переменной
     */
    'name'?: string;
    /**
     * Текстовое описание
     */
    'description'?: string;
    /**
     * Тип, который принимает поле
     */
    'type'?: ConnectionSchemaFieldsInnerTypeEnum;
    /**
     * Обязательно ли поле
     */
    'required'?: boolean;
    /**
     * Может ли поле принимать несколько значений
     */
    'multiple'?: boolean;
    /**
     * Объект с возможными значениями для поля. Если у поля type=array и multiple=false, то передавать значение не оборачивая в массив
     */
    'values'?: Array<ConnectionSchemaFieldsInnerValuesInner>;
}

export const ConnectionSchemaFieldsInnerTypeEnum = {
    Bool: 'bool',
    Int: 'int',
    Float: 'float',
    String: 'string',
    Array: 'array'
} as const;

export type ConnectionSchemaFieldsInnerTypeEnum = typeof ConnectionSchemaFieldsInnerTypeEnum[keyof typeof ConnectionSchemaFieldsInnerTypeEnum];

export interface ConnectionSchemaFieldsInnerValuesInner {
    /**
     * Название
     */
    'label'?: string;
    /**
     * Значение, которое нужно передавать
     */
    'value'?: string;
}
export interface Cost {
    /**
     * Оценочная стоимость / сумма страховки (в рублях). Совпадает с суммой оценочной стоимости по всем товарам(places[].items[].assessedCost)
     */
    'assessedCost': number;
    /**
     * Стоимость доставки с учетом НДС (в рублях)
     */
    'deliveryCost'?: number | null;
    /**
     * Процентная ставка НДС: - \'-1\' - Без НДС; - \'0\' - НДС 0%; - \'10\' - НДС 10%; - \'20\' - НДС 20%; - \'5\' - НДС 5%; - \'7\' - НДС 7%; 
     */
    'deliveryCostVat'?: CostDeliveryCostVatEnum | null;
    /**
     * Сумма наложенного платежа с учетом НДС (в рублях). Совпадает с суммой наложенного платежа по всем товарам(places[].items[].cost) + стоимостью доставки(cost.deliveryCost)
     */
    'codCost': number;
    /**
     * Флаг для указания стороны, которая платит за услуги доставки (0-отправитель, 1-получатель)
     */
    'isDeliveryPayedByRecipient'?: boolean | null;
    /**
     * Способ оплаты заказа: - 1 - Наличные; - 2 - Карта; - 3 - Смешанная оплата(наличные и карта) - 4 - Безналичная оплата (по счету)
     */
    'paymentMethod'?: CostPaymentMethodEnum | null;
    /**
     * Пороги стоимости доставки, используются для динамической стоимости доставки в случае частичного выкупа (Поддержка есть только у СДЭК, Logsis, Lpost)
     */
    'deliveryCostThresholds'?: Array<DeliveryCostThreshold>;
}

export const CostDeliveryCostVatEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_10: 10,
    NUMBER_20: 20,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type CostDeliveryCostVatEnum = typeof CostDeliveryCostVatEnum[keyof typeof CostDeliveryCostVatEnum];
export const CostPaymentMethodEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type CostPaymentMethodEnum = typeof CostPaymentMethodEnum[keyof typeof CostPaymentMethodEnum];

export interface CourierCallRequest {
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: number;
    /**
     * Дата отгрузки
     */
    'date': string;
    /**
     * Начальное время отгрузки
     */
    'timeStart': string;
    /**
     * Конечное время отгрузки
     */
    'timeEnd': string;
    /**
     * Вес всего заказа (в граммах)
     */
    'weight': number;
    /**
     * Ширина заказа (в сантиметрах)
     */
    'width': number;
    /**
     * Высота заказа (в сантиметрах)
     */
    'height': number;
    /**
     * Длина заказа (в сантиметрах)
     */
    'length': number;
    /**
     * Номера заказов которые планируются передать с этим курьером
     */
    'orderIds': Array<number>;
    /**
     * Почтовый индекс
     */
    'postIndex'?: string;
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode'?: string;
    /**
     * Область или республика или край
     */
    'region': string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Город или населенный пункт
     */
    'city': string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Улица
     */
    'street': string;
    /**
     * Дом
     */
    'house': string;
    /**
     * Строение/Корпус
     */
    'block'?: string;
    /**
     * Офис/Квартира
     */
    'office'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * 123
     */
    'addressString'?: string;
    /**
     * Название компании
     */
    'companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'contactName': string;
    /**
     * Контактный телефон
     */
    'phone': string;
    /**
     * Контактный email адрес
     */
    'email'?: string;
    /**
     * Комментарий
     */
    'comment'?: string | null;
    'extraParams'?: ExtraParamOnCourier;
}
export interface CourierCallResponse {
    /**
     * Номер заявки
     */
    'id'?: number;
    /**
     * Номер заявки в системе СД
     */
    'providerNumber'?: string;
    /**
     * Дополнительный номер заявки в системе СД
     */
    'additionalProviderNumber'?: string;
    /**
     * Дата создания заявки
     */
    'created'?: string;
    /**
     * Описан≠ие ошибки в случае невозможности вызова курьера
     */
    'error'?: string;
}
export interface CourierCar {
    /**
     * Цвет машины
     */
    'color'?: string;
    /**
     * Модель машины
     */
    'model'?: string;
    /**
     * Номер машины
     */
    'number'?: string;
}
export interface CreateAddressCodeRequest {
    /**
     * Код создаваемого адреса
     */
    'code': string;
    'recipient'?: Recipient;
    'sender'?: Sender;
}
export interface CreateAddressCodeResponse {
    /**
     * Статус создания от СД
     */
    'status'?: string;
    /**
     * Код адреса
     */
    'code'?: string;
    /**
     * Сообщение об ошибке при создании от СД
     */
    'errorMessage'?: string;
}
export interface CreateWarehouseRequest {
    /**
     * ID подключения к 5Пост (если не указано, создается по самому первому созданному подключению)
     */
    'providerConnectId'?: string;
    /**
     * Код региона, в котором находится склад
     */
    'regionCode': string;
    /**
     * Наименование федерального округа
     */
    'federalDistrict': string;
    'warehouse': X5Warehouse;
    'workingTime': Array<WorkingTime>;
    /**
     * Часовой пояс склада
     */
    'timezone': string;
}
export interface CreateWarehouseResponse {
    'status': string;
    'description'?: string;
    /**
     * Id точки
     */
    'pointId': number;
}
export interface CseSaveOwnerOfTheGoodsPostRequest {
    /**
     * Наименование контрагента
     */
    'OwnerName': string;
    /**
     * Юридическое наименование контрагента
     */
    'OwnerLegalName': string;
    /**
     * ИНН контрагента - 10 символов
     */
    'OwnerINN': string;
    /**
     * КПП контрагента - 9 символов
     */
    'OwnerKPP': string;
    /**
     * Наименование банка
     */
    'AccountName': string;
    /**
     * БИК – 9 символов
     */
    'AccountBIK': string;
    /**
     * Номер счета – 20 символов
     */
    'AccountNumber': string;
    /**
     * ID подключения к СД
     */
    'providerConnectId'?: string;
}
export interface DefaultData {
    /**
     * Контактный телефон по умолчанию
     */
    'sender.phone'?: string;
    /**
     * Город по умолчанию
     */
    'sender.city'?: string;
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2 по умолчанию
     */
    'sender.countryCode'?: string;
    /**
     * Улица по умолчанию
     */
    'sender.street'?: string;
    /**
     * Номер дома по умолчанию
     */
    'sender.house'?: string;
    /**
     * Тип забора груза по умолчанию
     */
    'order.pickupType'?: number;
    /**
     * Тип доставки по умолчанию
     */
    'order.deliveryType'?: number;
    /**
     * Сумма наложенного платежа будет считаться по указанной колонке или можно указать значение по умолчанию
     */
    'cost.codCost'?: string;
}
export interface DeleteOrderResponse {
    /**
     * Номер заказа
     */
    'orderId'?: number;
    /**
     * Дата удаления заказа
     */
    'deleted'?: string;
}
export interface DeliveryCostThreshold {
    /**
     * Стоимость доставки при выкупе на сумму до порогового значения
     */
    'deliveryCost': number;
    /**
     * Пороговое значение суммы выкупа товара
     */
    'threshold': number;
}
export interface DeliveryInterval {
    /**
     * Дата интервала. Значение будет null, если интервал статический(не изменяется)
     */
    'date'?: string | null;
    /**
     * Время \"от\"
     */
    'from'?: string;
    /**
     * Время \"до\"
     */
    'to'?: string;
}
export interface DeliveryType {
    'id'?: number;
    'name'?: string;
    'description'?: string;
}
export interface Dimensions {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
}
export interface DocumentsRequest {
    /**
     * Массив ID заказов
     */
    'orderIds': Array<number>;
    /**
     * Формат получаемого файла
     */
    'format'?: string;
}
export interface DpdBindPreorderPickupRequest {
    /**
     * Номер заказа
     */
    'orderId': string;
    'orderPickupNum': string;
}
export interface DpdBindPreorderPickupResponse {
    /**
     * Статус
     */
    'status'?: string;
    'orderPickupNum'?: string;
    /**
     * Сообщение об ошибке
     */
    'errorMessage'?: string;
}
export interface DpdCityObject {
    'id'?: number;
    'dpdCityId'?: number;
    'cityCode'?: string;
    'cityGuid'?: string;
    'cityName'?: string;
    'countryCode'?: string;
    'countryName'?: string;
    'regionCode'?: number;
    'regionName'?: string;
    'abbreviation'?: string;
    'isCodCost'?: number;
}
export interface ErrorOrderInfo {
    /**
     * ID заказа
     */
    'orderId'?: number;
    /**
     * Описание причины неудачного получения статуса по заказу
     */
    'message'?: string;
}
export interface ExtendedOrderData {
    'check'?: ExtendedOrderDataCheck | null;
    /**
     * Фактический вес отправления (граммы)
     */
    'factOrderWeight'?: number;
    /**
     * Фактический объём отправления (см3)
     */
    'factVolumeCm3'?: number;
    /**
     * Фактический вес отправления (граммы)
     */
    'factPlacesWeight'?: Array<ExtendedOrderDataFactPlacesWeightInner>;
    /**
     * Плановая стоимость доставки (рубли)
     */
    'planDeliveryCost'?: number;
    /**
     * Фактическая стоимость доставки (рубли)
     */
    'factDeliveryCost'?: number;
    /**
     * Фактическая стоимость возврата (рубли)
     */
    'factReturnDeliveryCost'?: number;
    /**
     * Фактический наложенный платеж (рубли)
     */
    'factCodCost'?: number;
    /**
     * Дата перечисления наложенного платежа
     */
    'factCodDate'?: string | null;
    /**
     * Тип оплаты: - \'cash\' - наличными; - \'card\' - картой; - \'common\' - наличными и кредитной карточкой; 
     */
    'usedPaymentMethod'?: ExtendedOrderDataUsedPaymentMethodEnum | null;
    'orderServicesDetails'?: Array<ExtendedOrderDataOrderServicesDetailsInner>;
    'returnReason'?: ExtendedOrderDataReturnReason | null;
}

export const ExtendedOrderDataUsedPaymentMethodEnum = {
    Cash: 'cash',
    Common: 'common',
    Card: 'card'
} as const;

export type ExtendedOrderDataUsedPaymentMethodEnum = typeof ExtendedOrderDataUsedPaymentMethodEnum[keyof typeof ExtendedOrderDataUsedPaymentMethodEnum];

export interface ExtendedOrderDataCheck {
    /**
     * Ссылка на чек
     */
    'url'?: string;
    /**
     * Номер фискального накопителя
     */
    'fiscalNumber'?: string;
    /**
     * Порядковый номер фискального документа
     */
    'fiscalDocumentNumber'?: string;
    /**
     * Фискальный признак документа
     */
    'fiscalAttribute'?: string;
    /**
     * 1 - приход; 2- возврат
     */
    'type'?: number;
    /**
     * Сумма по чеку (в рублях)
     */
    'amount'?: number;
    /**
     * Дата и время формирования чека
     */
    'createdProvider'?: string;
    /**
     * Дата и время получения информации о чеке
     */
    'created'?: string;
}
export interface ExtendedOrderDataFactPlacesWeightInner {
    /**
     * Номер грузоместа в ApiShip
     */
    'placeId'?: number;
    /**
     * Вес грузоместа (граммы)
     */
    'weight'?: number;
}
export interface ExtendedOrderDataOrderServicesDetailsInner {
    /**
     * Код услуги
     */
    'serviceKey'?: string;
    /**
     * Название услуги
     */
    'serviceName'?: string;
    /**
     * Код услуги в СД
     */
    'serviceProviderCode'?: string;
    /**
     * Название услуги в СД
     */
    'serviceProviderName'?: string;
    /**
     * Стоимость услуги (рубли)
     */
    'serviceProviderCost'?: string;
}
export interface ExtendedOrderDataReturnReason {
    /**
     * Код причины возврата
     */
    'returnReasonKey'?: string;
    /**
     * Описание причины возврата
     */
    'returnReasonName'?: string;
}
export interface ExternalTrackingDeleteOrderResponse {
    /**
     * ID отслеживания заказа
     */
    'orderId': string;
    /**
     * Дата и время удаления отслеживания заказа
     */
    'deletedAt': string;
}
export interface ExternalTrackingOrderResponseInner {
    /**
     * Номер заказа в системе службы доставки
     */
    'providerNumber'?: string;
    /**
     * Код службы доставки
     */
    'providerKey'?: string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: number;
    /**
     * ID отслеживания заказа
     */
    'orderId'?: string;
    'created'?: string;
}
export interface ExternalTrackingOrdersRequestInner {
    /**
     * Номер заказа в системе службы доставки
     */
    'providerNumber'?: string;
    /**
     * Код службы доставки
     */
    'providerKey'?: string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: number | null;
}
export interface ExtraParam {
    /**
     * Идентификатор дополнительного параметра
     */
    'key': string;
    /**
     * Значение дополнительного параметра
     */
    'value': string;
}
export interface ExtraParamOnCourier {
    /**
     * Идентификатор дополнительного параметра
     */
    'logsis.warehouse_code': string;
}
/**
 * Список
 */
export interface GetAllParams200Response {
    /**
     * Массив параметров
     */
    'rows'?: Array<Params>;
    'meta'?: PaginationMeta;
}
export interface GetCalculator200Response {
    'deliveryToDoor'?: Array<CalculatorToDoorResult>;
    'deliveryToPoint'?: Array<CalculatorToPointResult>;
}
export interface GetLabels200Response {
    'url'?: string;
    'failedOrders'?: Array<ErrorOrderInfo>;
}
/**
 * Список
 */
export interface GetListCitiesB2cpl200Response {
    'rows'?: Array<B2cplCityObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListCitiesBoxberry200Response {
    'rows'?: Array<BoxberryCityObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListCitiesCdek200Response {
    'rows'?: Array<CdekCityObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListCitiesDpd200Response {
    'rows'?: Array<DpdCityObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListPoints200Response {
    'rows'?: Array<PointObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListProviderStatuses200Response {
    'rows'?: Array<ProviderStatus>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListProviders200Response {
    'rows'?: Array<ProviderObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListStatuses200Response {
    'rows'?: Array<StatusObject>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetListTariffs200Response {
    'rows'?: Array<TariffObject>;
    'meta'?: PaginationMeta;
}
export interface GetOrderStatus200Response {
    'orderInfo'?: OrderInfo;
    'status'?: OrderStatus;
}
/**
 * Список
 */
export interface GetOrderStatusHistory200Response {
    'orderInfo'?: OrderInfo;
    /**
     * Массив статусов (сортировка created DESC)
     */
    'rows'?: Array<OrderStatus>;
    'meta'?: PaginationMeta;
}
export interface GetOrderStatusHistoryByClientNumber200Response {
    'orderInfo'?: OrderInfo;
    /**
     * Массив статусов (сортировка created DESC)
     */
    'statuses'?: Array<OrderStatus>;
}
/**
 * @type GetOrderStatusOrderIdParameter
 */
export type GetOrderStatusOrderIdParameter = number | string;

export interface GetOrderStatuses200Response {
    'succeedOrders'?: Array<StatusCommon>;
    'failedOrders'?: Array<ErrorOrderInfo>;
}
/**
 * Список
 */
export interface GetStatusHistoryByDate200Response {
    /**
     * Массив заказов с их статусами
     */
    'rows'?: Array<StatusHistoryByDate>;
    'meta'?: PaginationMeta;
}
/**
 * Список
 */
export interface GetStatusHistoryByInterval200Response {
    /**
     * Массив заказов с их статусами
     */
    'rows'?: Array<StatusHistoryByInterval>;
    'meta'?: PaginationMeta;
}
export interface GetWaybills200Response {
    'waybillItems'?: Array<WaybillItem>;
    'failedOrders'?: Array<ErrorOrderInfo>;
}
export interface Item {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight'?: number;
    /**
     * Артикул товара
     */
    'articul'?: string;
    /**
     * Код маркировки (UTF-8)
     */
    'markCode'?: string;
    /**
     * Наименование товара
     */
    'description': string;
    /**
     * Кол-во товара. Если указан markCode, то кол-во не может быть > 1
     */
    'quantity': number;
    /**
     * Заполняется только при частичной доставке и показывает сколько единиц товара выкуплено
     */
    'quantityDelivered'?: number | null;
    /**
     * Оценочная стоимость единицы товара в рублях
     */
    'assessedCost'?: number | null;
    /**
     * Стоимость единицы товара с учетом НДС в рублях
     */
    'cost'?: number | null;
    /**
     * Процентная ставка НДС: - \'-1\' - Без НДС; - \'0\' - НДС 0%; - \'10\' - НДС 10%; - \'20\' - НДС 20%; - \'5\' - НДС 5%; - \'7\' - НДС 7%; 
     */
    'costVat'?: ItemCostVatEnum | null;
    /**
     * Штрихкод на товаре
     */
    'barcode'?: string;
    /**
     * Наименование компании поставщика / продавца товара
     */
    'companyName'?: string;
    /**
     * ИНН поставщика / продавца товара
     */
    'companyInn'?: string;
    /**
     * Телефон поставщика / продавца товара
     */
    'companyPhone'?: string;
    /**
     * Код ТН ВЭД
     */
    'tnved'?: string;
    /**
     * Ссылка на страницу товара в интернет-магазине
     */
    'url'?: string;
}

export const ItemCostVatEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_10: 10,
    NUMBER_20: 20,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type ItemCostVatEnum = typeof ItemCostVatEnum[keyof typeof ItemCostVatEnum];

export interface LabelsRequest {
    /**
     * Массив ID заказов
     */
    'orderIds': Array<number>;
    /**
     * Формат вывода ярлыков (пока только pdf)
     */
    'format': string;
}
export interface ListConnectionResponse {
    /**
     * Массив объектов подключений
     */
    'rows'?: Array<Connection>;
    'meta'?: PaginationMeta;
}
export interface LoginRequest {
    /**
     * Логин пользователя. Имя или email.
     */
    'login': string;
    /**
     * Пароль пользователя
     */
    'password': string;
}
export interface LoginResponse {
    /**
     * Ключ безопасности
     */
    'token'?: string;
}
/**
 * @type LoginUser5XXResponse
 */
export type LoginUser5XXResponse = ServerError | ServiceError;

export interface LogsisConfirmOrderRequest {
    /**
     * Номер заказа
     */
    'orderId': string;
}
export interface LogsisConfirmOrderResponse {
    /**
     * Статус
     */
    'status'?: string;
    'response'?: Array<LogsisConfirmOrderResponseResponseInner>;
}
export interface LogsisConfirmOrderResponseResponseInner {
    /**
     * id заказа в службе доставки
     */
    'order_id'?: string;
    /**
     * inner_id
     */
    'inner_id'?: string;
    /**
     * Статус подтверждения
     */
    'Confirmed'?: string;
    /**
     * Ошибки
     */
    'Error'?: string;
}
export interface LogsisUpdateWarehouseRequest {
    /**
     * ID подключения к СД
     */
    'providerConnectId': string;
    'warehouseId': string;
    'code'?: string;
    'name': string;
    'working_hours': string;
    'is_returns_possible'?: boolean;
    'is_visible'?: boolean;
    'contact_name'?: string;
    'contact_phone': string;
    'address': string;
    'comment'?: string;
}
export interface LogsisUpdateWarehouseResponse {
    /**
     * Статус
     */
    'status'?: string;
    'response'?: Array<LogsisUpdateWarehouseResponseResponseInner>;
}
export interface LogsisUpdateWarehouseResponseResponseInner {
    'id'?: string;
    'code'?: string;
    'name'?: string;
    'working_hours'?: string;
    'is_returns_possible'?: boolean;
    'is_visible'?: boolean;
    'contact_name'?: string;
    'contact_phone'?: string;
    'address'?: string;
    'comment'?: string;
}
export interface ModelFile {
    /**
     * Файл, закодированный в base64 строку. Обязательно, если не заполнено поле url
     */
    'base64'?: string;
    /**
     * Ссылка на файл. Обязательно, если не заполнено поле base64
     */
    'url'?: string;
    /**
     * Тип файла
     */
    'type'?: string;
}
export interface OrderCourierResponse {
    /**
     * ID заказа
     */
    'orderId': number;
    /**
     * ФИО курьера
     */
    'fullName'?: string;
    /**
     * ID курьера в системе СД
     */
    'providerId'?: string;
    /**
     * Номер телефона курьера
     */
    'phone'?: string;
    'car'?: CourierCar;
}
export interface OrderData {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight': number;
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber': string;
    /**
     * Штрих-код
     */
    'barcode'?: string;
    /**
     * Комментарий
     */
    'description'?: string;
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: string;
    /**
     * Тип забора груза. 1 - отгрузка груза курьером; 2 - отгрузка груза на ПВЗ;
     */
    'pickupType': number;
    /**
     * Тип доставки. 1 - доставка курьером; 2 - доставка на ПВЗ;
     */
    'deliveryType': number;
    /**
     * Тариф службы доставки по которому осуществляется доставка
     */
    'tariffId': number;
    /**
     * ID точки приема заказа
     */
    'pointInId'?: number | null;
    /**
     * ID точки выдачи заказа
     */
    'pointOutId'?: number | null;
    /**
     * Предполагаемая дата передачи груза в службу доставки
     */
    'pickupDate'?: string | null;
    /**
     * Начальное время забора груза
     */
    'pickupTimeStart'?: string;
    /**
     * Конечное время забора груза
     */
    'pickupTimeEnd'?: string;
    /**
     * Дата доставки
     */
    'deliveryDate'?: string;
    /**
     * Начальное время доставки
     */
    'deliveryTimeStart'?: string;
    /**
     * Конечное время доставки
     */
    'deliveryTimeEnd'?: string;
    /**
     * Ссылка отслеживания из системы СД
     */
    'trackingUrl'?: string;
}
export interface OrderDataResponse {
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber': string;
    /**
     * Штрих-код
     */
    'barcode'?: string;
    /**
     * Комментарий
     */
    'description'?: string;
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: string;
    /**
     * Тип забора груза. 1 - отгрузка груза курьером; 2 - отгрузка груза на ПВЗ;
     */
    'pickupType': number;
    /**
     * Тип доставки. 1 - доставка курьером; 2 - доставка на ПВЗ;
     */
    'deliveryType': number;
    /**
     * Тариф службы доставки по которому осуществляется доставка
     */
    'tariffId': number;
    /**
     * ID точки приема заказа
     */
    'pointInId'?: number | null;
    /**
     * ID точки выдачи заказа
     */
    'pointOutId'?: number | null;
    /**
     * Предполагаемая дата передачи груза в службу доставки
     */
    'pickupDate'?: string | null;
    /**
     * Начальное время забора груза
     */
    'pickupTimeStart'?: string;
    /**
     * Конечное время забора груза
     */
    'pickupTimeEnd'?: string;
    /**
     * Дата доставки
     */
    'deliveryDate'?: string;
    /**
     * Начальное время доставки
     */
    'deliveryTimeStart'?: string;
    /**
     * Конечное время доставки
     */
    'deliveryTimeEnd'?: string;
    /**
     * Ссылка отслеживания из системы СД
     */
    'trackingUrl'?: string;
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight': number;
    /**
     * Номер заказа в системе службы доставки. Если СД выдает диапазон номеров заказа
     */
    'providerNumber'?: string;
    /**
     * Дополнительный номер заказа в системе службы доставки
     */
    'additionalProviderNumber'?: string;
}
export interface OrderInfo {
    'orderId'?: OrderInfoOrderId;
    /**
     * Код службы доставки
     */
    'providerKey'?: string;
    /**
     * Номер заказа в системе службы доставки
     */
    'providerNumber'?: string;
    /**
     * Номер возврата заказа в системе службы доставки
     */
    'returnProviderNumber'?: string;
    /**
     * Дополнительный номер заказа в системе службы доставки
     */
    'additionalProviderNumber'?: string;
    /**
     * Номер заказа для печати штрих-кода
     */
    'barcode'?: string;
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber'?: string;
    /**
     * Ссылка на отслеживание в системе СД
     */
    'trackingUrl'?: string;
}
export interface OrderInfoCost {
    /**
     * Оценочная стоимость / сумма страховки (в рублях). Совпадает с суммой оценочной стоимости по всем товарам(places[].items[].assessedCost)
     */
    'assessedCost': number;
    /**
     * Стоимость доставки с учетом НДС (в рублях)
     */
    'deliveryCost'?: number | null;
    /**
     * Процентная ставка НДС: - \'-1\' - Без НДС; - \'0\' - НДС 0%; - \'10\' - НДС 10%; - \'20\' - НДС 20%; - \'5\' - НДС 5%; - \'7\' - НДС 7%; 
     */
    'deliveryCostVat'?: OrderInfoCostDeliveryCostVatEnum | null;
    /**
     * Сумма наложенного платежа с учетом НДС (в рублях). Совпадает с суммой наложенного платежа по всем товарам(places[].items[].cost) + стоимостью доставки(cost.deliveryCost)
     */
    'codCost': number;
    /**
     * Флаг для указания стороны, которая платит за услуги доставки (0-отправитель, 1-получатель)
     */
    'isDeliveryPayedByRecipient'?: boolean | null;
    /**
     * Способ оплаты заказа: - 1 - Наличные; - 2 - Карта; - 3 - Смешанная оплата(наличные и карта) - 4 - Безналичная оплата (по счету)
     */
    'paymentMethod'?: OrderInfoCostPaymentMethodEnum | null;
    /**
     * Пороги стоимости доставки, используются для динамической стоимости доставки в случае частичного выкупа (Поддержка есть только у СДЭК, Logsis, Lpost)
     */
    'deliveryCostThresholds'?: Array<DeliveryCostThreshold>;
    /**
     * Каким способом получатель оплатил заказ (1-наличными, 2-кредитной картой)
     */
    'usedPaymentType'?: number;
}

export const OrderInfoCostDeliveryCostVatEnum = {
    NUMBER_MINUS_1: -1,
    NUMBER_0: 0,
    NUMBER_10: 10,
    NUMBER_20: 20,
    NUMBER_5: 5,
    NUMBER_7: 7
} as const;

export type OrderInfoCostDeliveryCostVatEnum = typeof OrderInfoCostDeliveryCostVatEnum[keyof typeof OrderInfoCostDeliveryCostVatEnum];
export const OrderInfoCostPaymentMethodEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type OrderInfoCostPaymentMethodEnum = typeof OrderInfoCostPaymentMethodEnum[keyof typeof OrderInfoCostPaymentMethodEnum];

export interface OrderInfoData {
    /**
     * Номер заказа в системе службы доставки. Если СД выдает диапазон номеров заказа
     */
    'providerNumber'?: string;
    /**
     * Дополнительный номер заказа в системе службы доставки
     */
    'additionalProviderNumber'?: string;
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber': string;
    /**
     * Штрих-код
     */
    'barcode'?: string;
    /**
     * Комментарий
     */
    'description'?: string;
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: string;
    /**
     * Тип забора груза. 1 - отгрузка груза курьером; 2 - отгрузка груза на ПВЗ;
     */
    'pickupType': number;
    /**
     * Тип доставки. 1 - доставка курьером; 2 - доставка на ПВЗ;
     */
    'deliveryType': number;
    /**
     * Тариф службы доставки по которому осуществляется доставка
     */
    'tariffId': number;
    /**
     * ID точки приема заказа
     */
    'pointInId'?: number | null;
    /**
     * ID точки выдачи заказа
     */
    'pointOutId'?: number | null;
    /**
     * Предполагаемая дата передачи груза в службу доставки
     */
    'pickupDate'?: string | null;
    /**
     * Начальное время забора груза
     */
    'pickupTimeStart'?: string;
    /**
     * Конечное время забора груза
     */
    'pickupTimeEnd'?: string;
    /**
     * Дата доставки
     */
    'deliveryDate'?: string;
    /**
     * Начальное время доставки
     */
    'deliveryTimeStart'?: string;
    /**
     * Конечное время доставки
     */
    'deliveryTimeEnd'?: string;
    /**
     * Ссылка отслеживания из системы СД
     */
    'trackingUrl'?: string;
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight': number;
    /**
     * ID заказа
     */
    'orderId'?: number;
}
/**
 * @type OrderInfoOrderId
 */
export type OrderInfoOrderId = number | string;

export interface OrderInfoResponse {
    'order'?: OrderInfoData;
    'cost'?: OrderInfoCost;
    'sender'?: Sender;
    'recipient'?: Recipient;
    'returnAddress'?: ReturnAddress;
    'items'?: Array<Item>;
    'places'?: Array<Place>;
    'extraParams'?: Array<ExtraParam>;
    'extendedInfo'?: ExtendedOrderData;
}
export interface OrderRequest {
    'order': OrderData;
    'cost': Cost;
    'sender': Sender;
    'recipient': Recipient;
    'returnAddress'?: ReturnAddress;
    /**
     * @deprecated
     */
    'items'?: Array<Item>;
    'places'?: Array<Place>;
    'extraParams'?: Array<ExtraParam>;
}
export interface OrderResponse {
    /**
     * Номер заказа
     */
    'orderId'?: number;
    /**
     * Дата создания заказа
     */
    'created'?: string;
}
export interface OrderReturnData {
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber': string;
    /**
     * Комментарий
     */
    'description'?: string;
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * ID подключения вашей компании к СД
     */
    'providerConnectId'?: string;
    /**
     * Тип забора груза. 1 - отгрузка груза курьером; 2 - отгрузка груза на ПВЗ;
     */
    'pickupType': number;
    /**
     * Тип доставки. 1 - доставка курьером; 2 - доставка на ПВЗ;
     */
    'deliveryType': number;
    /**
     * Тариф службы доставки по которому осуществляется доставка
     */
    'tariffId': number;
    /**
     * ID точки приема заказа
     */
    'pointInId'?: number;
    /**
     * ID точки выдачи заказа
     */
    'pointOutId'?: number;
}
export interface OrderReturnRequest {
    /**
     * Идентификатор прямого заказа (orderId из методов создания заказа)
     */
    'directOrderId'?: number;
    'order': OrderReturnData;
    'cost': ReturnCost;
    'sender': Sender;
    'recipient': Recipient;
    /**
     * @deprecated
     */
    'items'?: Array<ReturnItem>;
    'places'?: Array<Place>;
    'extraParams'?: Array<ExtraParam>;
}
/**
 * Статус заказа
 */
export interface OrderStatus {
    /**
     * Идентификатор статуса заказа
     */
    'key'?: string;
    /**
     * Название статуса
     */
    'name'?: string;
    /**
     * Описание статуса
     */
    'description'?: string;
    /**
     * дата и время установки данного статуса
     */
    'created'?: string;
    /**
     * Код статуса в системе службы доставки
     */
    'providerCode'?: string;
    /**
     * Название статуса в системе службы доставки
     */
    'providerName'?: string;
    /**
     * Описание статуса в системе службы доставки
     */
    'providerDescription'?: string;
    /**
     * Дата создания статуса в системе службы доставки
     */
    'createdProvider'?: string;
    /**
     * Коды ошибок: 100 - ошибка в ApiShip; 200 - ошибка в СД; 300 - ошибка клиента (некорректные данные).
     */
    'errorCode'?: string;
}
export interface OrderSyncResponse {
    /**
     * Номер заказа
     */
    'orderId'?: number;
    /**
     * Номер заказа в системе службы доставки
     */
    'providerNumber'?: string;
    /**
     * Дополнительный номер заказа в системе службы доставки
     */
    'additionalProviderNumber'?: string;
    /**
     * Дата создания заказа
     */
    'created'?: string;
}
export interface OrderUploadItem {
    /**
     * Номер заказа в системе клиента
     */
    'clientNumber': string;
    /**
     * Номер строки в таблице
     */
    'row': number;
    /**
     * Номер заказа в системе Apiship
     */
    'orderId'?: number;
    /**
     * Номер заказа в системе СД
     */
    'providerNumber'?: string;
    /**
     * Дата создания заказа
     */
    'created'?: string;
}
export interface OrderUploadResponse {
    /**
     * Массив данных о созданных заказах
     */
    'resultItems': Array<OrderUploadItem>;
    /**
     * Файл в base64 с описанием ошибок создания заказа
     */
    'base64'?: string;
}
export interface OrdersUploadRequest {
    /**
     * Код службы доставки
     */
    'providerKey': string;
    /**
     * Метод загрузки заказов
     */
    'mode'?: string;
    /**
     * Флаг возвращения base64 строки исходного файла с ошибками создания, если имеются. (true - в исходный файл будут записаны ошибки создания и в ответе будет возвращена base64 строка данного файла; false - в файл не будут записаны ошибки)
     */
    'errorsToFile'?: boolean;
    'file': any;
    'columnSettings': ColumnSettings;
    'columnMap': ColumnMap;
    'defaultData'?: DefaultData;
}
export interface PaginationMeta {
    'total'?: number;
    'offset'?: number;
    'limit'?: number;
}
export interface Params {
    'id'?: number;
    /**
     * ID компании
     */
    'companyId'?: number;
    /**
     * Ключ (alias) провайдера (службы доставки)
     */
    'providerKey'?: string;
    /**
     * Параметры подключения. Для разных служб - разные ключи в объекте
     */
    'connectParams'?: object;
    /**
     * Своя для компании процентная ставка страховки (%)
     */
    'insuranceRate'?: number;
    /**
     * Своя для компании процентная ставка кассового обслуживания (%)
     */
    'cashServiceRate'?: number;
    /**
     * Дата создания
     */
    'created'?: number;
    /**
     * Дата обновления
     */
    'updated'?: number;
    /**
     * Информация о связанной с настройками компании
     */
    'company'?: object;
}
export interface PayReceiptData {
    /**
     * Номер заказа в системе заказчика
     */
    'clientNumber'?: string;
    /**
     * Номер заказа для печати на бумажном чеке
     */
    'printNumber'?: string;
    /**
     * Тип чека sale - приход или return - возврат
     */
    'type': string;
    /**
     * Тип оплаты чека cash - наличные или card - банковская карта
     */
    'payType': string;
    /**
     * Итоговая цена в чеке
     */
    'totalPrice': number;
    /**
     * E-mail покупателя
     */
    'email'?: string;
    /**
     * Телефон покупателя
     */
    'phone'?: string;
}
export interface PayReceiptFiscalData {
    'receipt_number'?: number;
    'model_number'?: string;
    'factory_kkt_number'?: string;
    'factory_fn_number'?: string;
    'registration_number'?: string;
    'fn_expired_period'?: number;
    'fd_number'?: number;
    'fpd'?: number;
    'registration_date'?: string;
    'fn_expired_at'?: string;
}
export interface PayReceiptFullResponse {
    /**
     * Номер чека
     */
    'id'?: number;
    /**
     * Номер чека в системе ОФД
     */
    'providerNumber'?: string;
    /**
     * Статус чека 0-новый, 1-был отправлен в ОФД, 2-обрабатывается ОФД, 3-успешно обработан, 4-ошибка
     */
    'status'?: number;
    /**
     * Текстовое описание текущего статуса (или текст ошибки при соответствующем статусе)
     */
    'statusDescription'?: string;
    /**
     * Дата создания чека
     */
    'created'?: string;
    /**
     * Ссылка на изображение чека
     */
    'receiptImage'?: string;
    'fiscalData'?: PayReceiptFiscalData;
    'payReceipt'?: PayReceiptData;
    'items'?: Array<PayReceiptItem>;
}
export interface PayReceiptItem {
    /**
     * Стоимость единицы товара с учетом НДС в рублях
     */
    'price': number;
    /**
     * Кол-во товара
     */
    'quantity': number;
    /**
     * Наименование товара
     */
    'title': string;
    /**
     * Код процентной ставки НДС
     */
    'vatRate'?: number;
    /**
     * Штрихкод на товаре
     */
    'barcode'?: string;
    /**
     * Наименование компании поставщика / продавца товара
     */
    'companyName'?: string;
    /**
     * ИНН поставщика / продавца товара
     */
    'companyInn'?: string;
}
export interface PayReceiptRequest {
    'payReceipt': PayReceiptData;
    'items': Array<PayReceiptItem>;
    'shouldPrint'?: boolean;
}
export interface PayReceiptResponse {
    /**
     * Номер чека
     */
    'id'?: number;
    /**
     * Номер чека в системе ОФД
     */
    'providerNumber'?: string;
    /**
     * Статус чека 0-новый, 1-был отправлен в ОФД, 2-обрабатывается ОФД, 3-успешно обработан, 4-ошибка
     */
    'status'?: number;
    /**
     * Текстовое описание текущего статуса (или текст ошибки при соответствующем статусе)
     */
    'statusDescription'?: string;
    /**
     * Дата создания чека
     */
    'created'?: string;
    /**
     * Ссылка на изображение чека
     */
    'receiptImage'?: string;
    'fiscalData'?: PayReceiptFiscalData;
}
export interface PaymentMethod {
    'id'?: number;
    'name'?: string;
    'description'?: string;
}
export interface PickupType {
    'id'?: number;
    'name'?: string;
    'description'?: string;
}
export interface Place {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight': number;
    /**
     * Номер места в информационной системе клиента
     */
    'placeNumber'?: string;
    /**
     * ШК места
     */
    'barcode'?: string;
    'items': Array<Item>;
}
export interface PlaceResponse {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight': number;
    /**
     * Номер места в информационной системе клиента
     */
    'placeNumber'?: string;
    /**
     * ШК места
     */
    'barcode'?: string;
    'items': Array<Item>;
    /**
     * Номер грузоместа в СД
     */
    'providerNumber'?: string;
    /**
     * ШК места, полученный от провайдера
     */
    'providerBarcode'?: string;
}
export interface PlacementCodeResponse {
    /**
     * ID заказа
     */
    'orderId': number;
    /**
     * Код размещения заказа
     */
    'code'?: string | null;
}
export interface PointObject {
    'id'?: number;
    /**
     * Идентификатор службы доставки
     */
    'providerKey'?: string;
    /**
     * Признаки отношения к другим СД, Франшизам и т.д.
     */
    'providerKeyOriginal'?: string;
    /**
     * Код терминала в системе службы доставки
     */
    'code'?: string;
    /**
     * Название
     */
    'name'?: string;
    /**
     * Индекс
     */
    'postIndex'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Код страны
     */
    'countryCode'?: string;
    /**
     * Регион
     */
    'region'?: string;
    /**
     * Тип региона
     */
    'regionType'?: string;
    /**
     * Город
     */
    'city'?: string;
    /**
     * ФИАС-код города
     */
    'cityGuid'?: string;
    /**
     * Тип города
     */
    'cityType'?: string;
    /**
     * Населенный пункт
     */
    'community'?: string;
    /**
     * ФИАС-код населенного пункта
     */
    'communityGuid'?: string;
    /**
     * Тип населенного пункта
     */
    'communityType'?: string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Улица
     */
    'street'?: string;
    /**
     * Тип улицы (ул., переулок и т.п.)
     */
    'streetType'?: string;
    /**
     * Дом
     */
    'house'?: string;
    /**
     * Корпус
     */
    'block'?: string;
    /**
     * Офис
     */
    'office'?: string;
    /**
     * Полный адрес, полученный от СД
     */
    'address'?: string;
    /**
     * Домашняя страница
     */
    'url'?: string;
    /**
     * email
     */
    'email'?: string;
    /**
     * Телефон
     */
    'phone'?: string;
    /**
     * Режим работы
     */
    'timetable'?: string;
    'worktime'?: PointObjectWorktime;
    /**
     * Наличие примерочной
     */
    'fittingRoom'?: number;
    /**
     * Имеется ли возможность оплаты при доставке (null - нет данных, 1 - оплата доступна, 0 - оплата не доступна)
     */
    'cod'?: number;
    /**
     * Имеется ли возможность оплаты наличными (null - нет данных, 1 - оплата наличными доступна, 0 - оплата наличными не доступна)
     */
    'paymentCash'?: number;
    /**
     * Имеется ли возможность оплаты банковской картой (null - нет данных, 1 - оплата картой доступна, 0 - оплата картой не доступна)
     */
    'paymentCard'?: number;
    /**
     * Возможна ли выдача многоместных отправлений (null - нет данных, 1 - выдача возможна, 0 - выдача невозможна)
     */
    'multiplaceDeliveryAllowed'?: number;
    /**
     * Тип операции (1 - прием, 2 - выдача, 3 - прием и выдача)
     */
    'availableOperation'?: number;
    /**
     * Тип точки (1 - Пункт выдачи заказа, 2 - Постамат, 3 - Отделение Почты России, 4 - Терминал)
     */
    'type'?: number;
    /**
     * Описание ПВЗ, как пройти
     */
    'description'?: string;
    'photos'?: Array<string>;
    /**
     * Список ближайших станций метро (до трёх штук)
     */
    'metro'?: Array<PointObjectMetroInner>;
    /**
     * Дополнительные параметры для службы
     */
    'extra'?: Array<PointObjectExtraInner>;
    'limits'?: PointObjectLimits;
    /**
     * Доступность пункта
     */
    'enabled'?: boolean;
}
export interface PointObjectExtraInner {
    /**
     * Название дополнительного параметра
     */
    'key'?: string;
    /**
     * Значение дополнительного параметра
     */
    'value'?: string;
}
export interface PointObjectLimits {
    /**
     * Максимальная длина стороны А в см
     */
    'maxSizeA'?: number;
    /**
     * Максимальная длина стороны B в см
     */
    'maxSizeB'?: number;
    /**
     * Максимальная длина стороны С в см
     */
    'maxSizeC'?: number;
    /**
     * Максимальная сумма длин всех сторон в см
     */
    'maxSizeSum'?: number;
    /**
     * Минимальный вес в г
     */
    'minWeight'?: number;
    /**
     * Максимальный вес в г
     */
    'maxWeight'?: number;
    /**
     * Максимальная сумма наложенного платежа в рублях
     */
    'maxCod'?: number;
    /**
     * Максимальный объем в см3
     */
    'maxVolume'?: number;
}
export interface PointObjectMetroInner {
    /**
     * Название метро
     */
    'name'?: string;
    /**
     * Расстояние до метро в км
     */
    'distance'?: number;
    /**
     * Линия метро
     */
    'line'?: string;
}
/**
 * Режим работы по дням (1 - пн; 7 - вс) Отсутствие дня означает выходной
 */
export interface PointObjectWorktime {
    /**
     * Время работы в понедельник
     */
    '1'?: string;
    /**
     * Время работы во вторник
     */
    '2'?: string;
    /**
     * Время работы в среду
     */
    '3'?: string;
    /**
     * Время работы в четверг
     */
    '4'?: string;
    /**
     * Время работы в пятницу
     */
    '5'?: string;
    /**
     * Время работы в субботу
     */
    '6'?: string;
    /**
     * Время работы в воскресенье
     */
    '7'?: string;
}
export interface PointOperation {
    'id'?: number;
    'description'?: string;
}
export interface PointType {
    'id'?: number;
    'description'?: string;
}
export interface ProviderObject {
    /**
     * Идентификатор службы доставки
     */
    'key'?: string;
    /**
     * Название службы доставки
     */
    'name'?: string;
    /**
     * Описание службы доставки
     */
    'description'?: string;
}
export interface ProviderStatus {
    /**
     * Идентификатор статуса
     */
    'id'?: string;
    /**
     * Код статуса в сервисе
     */
    'code'?: string;
    /**
     * Название статуса в сервисе
     */
    'name'?: string;
    /**
     * Описание статуса в сервисе
     */
    'description'?: string;
    /**
     * Код статуса в СД
     */
    'providerCode'?: string;
    /**
     * Название статуса в СД
     */
    'providerName'?: string;
    /**
     * Описание статуса в СД
     */
    'providerDescription'?: string;
    'provider'?: ProviderStatusProvider;
}
export interface ProviderStatusProvider {
    /**
     * Ключ СД
     */
    'key'?: string;
    /**
     * Название СД
     */
    'name'?: string;
}
export interface Recipient {
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode': string;
    /**
     * Почтовый индекс
     */
    'postIndex'?: string;
    /**
     * Область или республика или край
     */
    'region'?: string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Город или населенный пункт
     */
    'city'?: string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Населённый пункт
     */
    'community'?: string | null;
    /**
     * ID населённого пункта в базе ФИАС
     */
    'communityGuid'?: string | null;
    /**
     * Улица
     */
    'street'?: string;
    /**
     * Дом
     */
    'house'?: string;
    /**
     * Строение/Корпус
     */
    'block'?: string;
    /**
     * Офис/Квартира
     */
    'office'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Полный адрес одной строкой. При заполнении этого поля остальные можно не заполнять, кроме countryCode
     */
    'addressString': string;
    /**
     * Название компании
     */
    'companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'contactName': string;
    /**
     * Контактный телефон
     */
    'phone': string;
    /**
     * Контактный email адрес
     */
    'email'?: string;
    /**
     * Комментарий
     */
    'comment'?: string;
    /**
     * ИНН компании
     */
    'companyInn'?: string;
    /**
     * Дополнительный телефон
     */
    'additionalPhone'?: string;
}
export interface ReturnAddress {
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode': string;
    /**
     * Почтовый индекс
     */
    'postIndex'?: string;
    /**
     * Область или республика или край
     */
    'region'?: string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Город или населенный пункт
     */
    'city'?: string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Населённый пункт
     */
    'community'?: string | null;
    /**
     * ID населённого пункта в базе ФИАС
     */
    'communityGuid'?: string | null;
    /**
     * Улица
     */
    'street'?: string;
    /**
     * Дом
     */
    'house'?: string;
    /**
     * Строение/Корпус
     */
    'block'?: string;
    /**
     * Офис/Квартира
     */
    'office'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Полный адрес одной строкой. При заполнении этого поля остальные можно не заполнять, кроме countryCode
     */
    'addressString': string;
    /**
     * Название компании
     */
    'companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'contactName': string;
    /**
     * Контактный телефон
     */
    'phone': string;
    /**
     * Контактный email адрес
     */
    'email'?: string;
    /**
     * Комментарий
     */
    'comment'?: string;
}
export interface ReturnCost {
    /**
     * Оценочная стоимость / сумма страховки (в рублях)
     */
    'assessedCost': number;
}
export interface ReturnItem {
    /**
     * Вес единицы товара в граммах
     */
    'weight'?: number;
    /**
     * Артикул товара
     */
    'articul'?: string;
    /**
     * Код маркировки (UTF-8)
     */
    'markCode'?: string;
    /**
     * Наименование товара
     */
    'description': string;
    /**
     * Кол-во товара. Если указан markCode, то кол-во не может быть > 1
     */
    'quantity': number;
    /**
     * Оценочная стоимость единицы товара в рублях
     */
    'assessedCost'?: number;
    /**
     * Штрихкод на товаре
     */
    'barcode'?: string;
    /**
     * Наименование компании поставщика / продавца товара
     */
    'companyName'?: string;
    /**
     * ИНН поставщика / продавца товара
     */
    'companyInn'?: string;
    /**
     * Телефон поставщика / продавца товара
     */
    'companyPhone'?: string;
}
export interface SaveOwnerOfTheGoods {
    /**
     * Наименование контрагента
     */
    'OwnerName': string;
    /**
     * Юридическое наименование контрагента
     */
    'OwnerLegalName': string;
    /**
     * ИНН контрагента - 10 символов
     */
    'OwnerINN': string;
    /**
     * КПП контрагента - 9 символов
     */
    'OwnerKPP': string;
    /**
     * Наименование банка
     */
    'AccountName': string;
    /**
     * БИК – 9 символов
     */
    'AccountBIK': string;
    /**
     * Номер счета – 20 символов
     */
    'AccountNumber': string;
}
export interface SchemasConnectionResponse {
    'rows'?: Array<ConnectionSchema>;
    'meta'?: PaginationMeta;
}
export interface Sender {
    /**
     * Код страны в соответствии с ISO 3166-1 alpha-2
     */
    'countryCode': string;
    /**
     * Почтовый индекс
     */
    'postIndex'?: string;
    /**
     * Область или республика или край
     */
    'region'?: string;
    /**
     * Район
     */
    'area'?: string;
    /**
     * Город или населенный пункт
     */
    'city'?: string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Населённый пункт
     */
    'community'?: string | null;
    /**
     * ID населённого пункта в базе ФИАС
     */
    'communityGuid'?: string | null;
    /**
     * Улица
     */
    'street'?: string;
    /**
     * Дом
     */
    'house'?: string;
    /**
     * Строение/Корпус
     */
    'block'?: string;
    /**
     * Офис/Квартира
     */
    'office'?: string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Полный адрес одной строкой. При заполнении этого поля остальные можно не заполнять, кроме countryCode
     */
    'addressString': string;
    /**
     * Название компании
     */
    'companyName'?: string;
    /**
     * ФИО контактного лица
     */
    'contactName': string;
    /**
     * Контактный телефон
     */
    'phone': string;
    /**
     * Контактный email адрес
     */
    'email'?: string;
    /**
     * Комментарий
     */
    'comment'?: string;
    /**
     * ИНН компании
     */
    'companyInn'?: string;
    /**
     * Дополнительный телефон
     */
    'additionalPhone'?: string;
    /**
     * Бренд продавца
     */
    'brandName'?: string;
}
export interface ServerError {
    /**
     * Описание ошибки сервера
     */
    'message'?: string;
}
/**
 * Bad request
 */
export interface ServiceError {
    /**
     * Код ошибки: * \'040301\' - (HTTP-STATUS: 403) Доступ запрещен; * \'040302\' - (HTTP-STATUS: 403) Некорректный пароль; * \'040303\' - (HTTP-STATUS: 403) Пользователь с указанным логином не существует; * \'040101\' - (HTTP-STATUS: 401) Некорректный ключ безопасности; * \'040304\' - (HTTP-STATUS: 403) Срок службы ключа безопасности истек; * \'040305\' - (HTTP-STATUS: 403) Заказ принадлежит другому клиенту; * \'040306\' - (HTTP-STATUS: 403) Служба доставки не поддерживает отмену заказа; * \'040307\' - (HTTP-STATUS: 400) Служба доставки не поддерживает отмену заявки; * \'040308\' - (HTTP-STATUS: 403) Недостаточно прав для вызова данного метода; * \'040309\' - (HTTP-STATUS: 403) Чек принадлежит другому клиенту; * \'040080\' - (HTTP-STATUS: 404) Указанного заказа не существует; * \'040081\' - (HTTP-STATUS: 400) Указанный заказ уже отменен; * \'040082\' - (HTTP-STATUS: 400) Указанная заявка уже отменена; * \'040083\' - (HTTP-STATUS: 400) Указанная заявка не была передана в СД; * \'040084\' - (HTTP-STATUS: 400) Заявка не может быть отменена, подробнее в errors; * \'040085\' - (HTTP-STATUS: 400) Чек не был передан в ОФД; * \'040086\' - (HTTP-STATUS: 400) Ошибка при получении статуса чека; * \'040087\' - (HTTP-STATUS: 404) Указанного чека не существует; * \'040088\' - (HTTP-STATUS: 400) Ошибка при создании заказа в СД; * \'040089\' - (HTTP-STATUS: 400) Ошибка при обновлении заказа в СД; * \'040000\' - (HTTP-STATUS: 400) Общая ошибка валидации, смотрите документацию; * \'040001\' - (HTTP-STATUS: 400) Ошибка валидации при попытке аутентификации; * \'040002\' - (HTTP-STATUS: 400) Ошибка валидации; * \'040003\' - (HTTP-STATUS: 400) Ошибка валидации при попытке рассчитать стоимость доставки; * \'040004\' - (HTTP-STATUS: 400) Неправильная кодировка. Кодировка должна быть UTF-8; * \'040005\' - (HTTP-STATUS: 400) Для Вашей компании нет параметров доступа в данную службы доставки; * \'040006\' - (HTTP-STATUS: 400) У Вашей компании нет подключенных СД; * \'040010\' - (HTTP-STATUS: 400) Фильтр не валидный, смотрите документацию; * \'040011\' - (HTTP-STATUS: 400) В фильтре присутствуют поля, по которым фильтрация не осуществляется; * \'040012\' - (HTTP-STATUS: 400) В поле fields присутствуют поля, которые не доступны для клиентов; * \'040013\' - (HTTP-STATUS: 400) В поле with присутствуют поля, которые не доступны для клиентов или недопустимы; * \'040014\' - (HTTP-STATUS: 400) Не удалось получить файл для импорта; * \'040015\' - (HTTP-STATUS: 400) Ошибка создания кода адреса в СД; * \'040016\' - (HTTP-STATUS: 404) Не найдено; * \'040017\' - (HTTP-STATUS: 400) Неверная ссылка; * \'040018\' - (HTTP-STATUS: 404) У заказа нет статусов; * \'040901\' - (HTTP-STATUS: 409) Пользователь с таким логином уже существует; * \'040902\' - (HTTP-STATUS: 409) Параметры подключения для данной СД уже созданы; * \'050001\' - (HTTP-STATUS: 500) Свяжитесь с администрацией; * \'060001\' - (HTTP-STATUS: 402) Пополните баланс для использования сервиса калькуляции; 
     */
    'code'?: ServiceErrorCodeEnum;
    /**
     * Сообщение об ошибке. Сервер отдает это поле всегда. Остальные могут не отдаваться в различных сценариях.
     */
    'message'?: string;
    /**
     * Описание ошибки
     */
    'description'?: string;
    /**
     * Дополнительная информация для решения ошибки
     */
    'moreInfo'?: string;
    /**
     * Детализированная информация об ошибке
     */
    'errors'?: Array<ServiceErrorErrorsInner>;
}

export const ServiceErrorCodeEnum = {
    _040301: '040301',
    _040302: '040302',
    _040303: '040303',
    _040101: '040101',
    _040304: '040304',
    _040305: '040305',
    _040306: '040306',
    _040307: '040307',
    _040308: '040308',
    _040309: '040309',
    _040080: '040080',
    _040081: '040081',
    _040082: '040082',
    _040083: '040083',
    _040084: '040084',
    _040085: '040085',
    _040086: '040086',
    _040087: '040087',
    _040088: '040088',
    _040089: '040089',
    _040000: '040000',
    _040001: '040001',
    _040002: '040002',
    _040003: '040003',
    _040004: '040004',
    _040005: '040005',
    _040006: '040006',
    _040010: '040010',
    _040011: '040011',
    _040012: '040012',
    _040013: '040013',
    _040014: '040014',
    _040015: '040015',
    _040016: '040016',
    _040017: '040017',
    _040018: '040018',
    _040901: '040901',
    _040902: '040902',
    _050001: '050001',
    _060001: '060001'
} as const;

export type ServiceErrorCodeEnum = typeof ServiceErrorCodeEnum[keyof typeof ServiceErrorCodeEnum];

export interface ServiceErrorErrorsInner {
    /**
     * Названия поля
     */
    'field'?: string;
    /**
     * Детальное сообщение об ошибке
     */
    'message'?: string;
}
export interface SignupUserRequest {
    'login'?: string;
    'email'?: string;
    'password'?: string;
}
export interface Sizes {
    /**
     * Высота единицы товара в сантиметрах
     */
    'height'?: number | null;
    /**
     * Длина единицы товара в сантиметрах
     */
    'length'?: number | null;
    /**
     * Ширина единицы товара в сантиметрах
     */
    'width'?: number | null;
    /**
     * Вес единицы товара в граммах
     */
    'weight'?: number;
}
/**
 * Информация о статусе заказа с описанием заказа
 */
export interface StatusCommon {
    'orderInfo'?: OrderInfo;
    'status'?: OrderStatus;
}
/**
 * Информация об истории статусов заказов с описанием заказа
 */
export interface StatusHistoryByDate {
    'orderInfo'?: OrderInfo;
    /**
     * Массив истории статусов
     */
    'statuses'?: Array<OrderStatus>;
}
/**
 * Информация об истории статусов заказов с описанием заказа
 */
export interface StatusHistoryByInterval {
    'orderInfo'?: OrderInfo;
    /**
     * Массив истории статусов
     */
    'statuses'?: Array<OrderStatus>;
}
export interface StatusIdsRequest {
    /**
     * Массив ID заказов (Предел 100 заказов)
     */
    'orderIds': Array<StatusIdsRequestOrderIdsInner>;
}
/**
 * @type StatusIdsRequestOrderIdsInner
 */
export type StatusIdsRequestOrderIdsInner = number | string;

export interface StatusObject {
    /**
     * Идентификатор статуса
     */
    'key'?: string;
    /**
     * Название статуса
     */
    'name'?: string;
    /**
     * Описание статуса
     */
    'description'?: string;
}
export interface SuccessResponse {
    'message'?: string;
}
export interface TariffObject {
    /**
     * Идентификатор тарифа
     */
    'id'?: number;
    /**
     * Идентификатор службы доставки, которой принадлежит тариф
     */
    'providerKey'?: string;
    /**
     * Название тарифа
     */
    'name'?: string;
    /**
     * Описание тарифа
     */
    'description'?: string;
    /**
     * Альтернативное название тарифа
     */
    'aliasName'?: string;
    /**
     * Минимальное ограничение по весу для тарифа (граммы)
     */
    'weightMin'?: number;
    /**
     * Максимальное ограничение по весу для тарифа (граммы)
     */
    'weightMax'?: number;
    /**
     * Тип приема тарифа (1 - от двери, 2 - от ПВЗ, null - доступны оба варианта)
     */
    'pickupType'?: number;
    /**
     * Тип выдачи тарифа (1 - до двери, 2 - до ПВЗ, null - доступны оба варианта)
     */
    'deliveryType'?: number;
}
export interface UpdateOrderItemsRequest {
    'items': Array<Item>;
}
export interface UserResponse {
    /**
     * ИД
     */
    'id'?: string;
    /**
     * ИД компании
     */
    'companyId'?: string;
    'login'?: string;
    'email'?: string;
    /**
     * Доступные роли пользователя
     */
    'roles'?: Array<string>;
    /**
     * Заказ создается как черновик
     */
    'useDraft'?: boolean;
    /**
     * Дата принятия оферты
     */
    'offerAccepted'?: string;
    /**
     * Дата создания
     */
    'created'?: string;
    /**
     * Дата изменения
     */
    'updated'?: string;
}
export interface ValidateOrderResponse {
    /**
     * Статус
     */
    'valid'?: boolean;
}
export interface WarehouseBoxberry {
    /**
     * Наименование склада
     */
    'name': string;
    /**
     * Почтовый индекс
     */
    'zip'?: string;
    /**
     * Адрес склада
     */
    'address'?: string;
    /**
     * Контактное лицо
     */
    'contactPerson'?: string;
    /**
     * Контактный телефон
     */
    'contactPhone'?: string;
    /**
     * Код пункта приема Боксберри
     */
    'receptionPointCode': string;
}
export interface WarehouseCreateBoxberry {
    /**
     * Наименование склада
     */
    'name': string;
    /**
     * Почтовый индекс
     */
    'zip'?: string;
    /**
     * Адрес склада
     */
    'address'?: string;
    /**
     * Контактное лицо
     */
    'contactPerson'?: string;
    /**
     * Контактный телефон
     */
    'contactPhone'?: string;
    /**
     * Код пункта приема Боксберри
     */
    'receptionPointCode': string;
    /**
     * Уникальный код склада
     */
    'code': string;
}
export interface WarehouseInfoBoxberry {
    /**
     * Наличие ошибки при выполнении
     */
    'err'?: boolean;
    /**
     * Список складов типа WarehouseCreateBoxberry
     */
    'warehouses'?: Array<WarehouseCreateBoxberry>;
}
export interface WaybillItem {
    /**
     * Ключ службы доставки
     */
    'providerKey'?: string;
    /**
     * Путь к накладной
     */
    'file'?: string;
    /**
     * Массив ID заказов, для которой сгенерирована накладная
     */
    'orderIds'?: Array<number>;
}
export interface WebhookListResponseInner {
    /**
     * Уникальный идентификатор подписки
     */
    'uuid'?: string;
    /**
     * URL, на который будут отправляться запросы
     */
    'url'?: string;
    /**
     * Тип события
     */
    'type'?: WebhookListResponseInnerTypeEnum;
}

export const WebhookListResponseInnerTypeEnum = {
    OrderStatus: 'ORDER_STATUS'
} as const;

export type WebhookListResponseInnerTypeEnum = typeof WebhookListResponseInnerTypeEnum[keyof typeof WebhookListResponseInnerTypeEnum];

export interface WebhookSubscribeRequest {
    /**
     * URL, на который будут отправляться запросы
     */
    'url': string;
    /**
     * Тип события
     */
    'type': WebhookSubscribeRequestTypeEnum;
}

export const WebhookSubscribeRequestTypeEnum = {
    OrderStatus: 'ORDER_STATUS'
} as const;

export type WebhookSubscribeRequestTypeEnum = typeof WebhookSubscribeRequestTypeEnum[keyof typeof WebhookSubscribeRequestTypeEnum];

export interface WebhookSubscribeResponse {
    /**
     * Уникальный идентификатор подписки
     */
    'uuid': string;
}
export interface WebhookSubscriptionDeleteResponse {
    /**
     * Уникальный идентификатор подписки
     */
    'uuid': string;
}
export interface WorkingTime {
    /**
     * День недели(1 - пн; 7 - вс)
     */
    'numberDayOfWeek': number;
    /**
     * Время начала работы склада
     */
    'timeStart': string;
    /**
     * Время окончания работы
     */
    'timeEnd': string;
}
export interface X5Warehouse {
    /**
     * Код склада в системе клиента
     */
    'code': string;
    /**
     * Название
     */
    'name': string;
    /**
     * Индекс
     */
    'postIndex': string;
    /**
     * Широта
     */
    'lat'?: number;
    /**
     * Долгота
     */
    'lng'?: number;
    /**
     * Код страны
     */
    'countryCode': string;
    /**
     * Регион
     */
    'region': string;
    /**
     * Тип региона
     */
    'regionType'?: string;
    /**
     * Город
     */
    'city': string;
    /**
     * ID города в базе ФИАС
     */
    'cityGuid'?: string;
    /**
     * Тип населенного пункта
     */
    'cityType'?: string;
    /**
     * Район
     */
    'area': string;
    /**
     * Улица
     */
    'street': string;
    /**
     * Тип улицы (ул., переулок и т.п.)
     */
    'streetType'?: string;
    /**
     * Дом
     */
    'house': string;
    /**
     * Корпус
     */
    'block'?: string;
    /**
     * Офис
     */
    'office'?: string;
    /**
     * Полный адрес
     */
    'address'?: string;
    /**
     * Телефон
     */
    'phone': string;
}

/**
 * ApiPayApi - axios parameter creator
 */
export const ApiPayApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получает статуса по чеку
         * @summary Получение статуса по чеку
         * @param {number} receiptId ID чека
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayReceiptStatus: async (receiptId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiptId' is not null or undefined
            assertParamExists('getPayReceiptStatus', 'receiptId', receiptId)
            const localVarPath = `/pay/receipt/{receiptId}`
                .replace(`{${"receiptId"}}`, encodeURIComponent(String(receiptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправка чека в ОФД
         * @summary Отправка чека
         * @param {PayReceiptRequest} [payReceiptRequest] Объект типа PayReceiptRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayReceipt: async (payReceiptRequest?: PayReceiptRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pay/receipt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(payReceiptRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiPayApi - functional programming interface
 */
export const ApiPayApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiPayApiAxiosParamCreator(configuration)
    return {
        /**
         * Получает статуса по чеку
         * @summary Получение статуса по чеку
         * @param {number} receiptId ID чека
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayReceiptStatus(receiptId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayReceiptFullResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayReceiptStatus(receiptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiPayApi.getPayReceiptStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отправка чека в ОФД
         * @summary Отправка чека
         * @param {PayReceiptRequest} [payReceiptRequest] Объект типа PayReceiptRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayReceipt(payReceiptRequest?: PayReceiptRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayReceiptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayReceipt(payReceiptRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiPayApi.sendPayReceipt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiPayApi - factory interface
 */
export const ApiPayApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiPayApiFp(configuration)
    return {
        /**
         * Получает статуса по чеку
         * @summary Получение статуса по чеку
         * @param {ApiPayApiGetPayReceiptStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayReceiptStatus(requestParameters: ApiPayApiGetPayReceiptStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<PayReceiptFullResponse> {
            return localVarFp.getPayReceiptStatus(requestParameters.receiptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Отправка чека в ОФД
         * @summary Отправка чека
         * @param {ApiPayApiSendPayReceiptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayReceipt(requestParameters: ApiPayApiSendPayReceiptRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PayReceiptResponse> {
            return localVarFp.sendPayReceipt(requestParameters.payReceiptRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPayReceiptStatus operation in ApiPayApi.
 */
export interface ApiPayApiGetPayReceiptStatusRequest {
    /**
     * ID чека
     */
    readonly receiptId: number
}

/**
 * Request parameters for sendPayReceipt operation in ApiPayApi.
 */
export interface ApiPayApiSendPayReceiptRequest {
    /**
     * Объект типа PayReceiptRequest
     */
    readonly payReceiptRequest?: PayReceiptRequest
}

/**
 * ApiPayApi - object-oriented interface
 */
export class ApiPayApi extends BaseAPI {
    /**
     * Получает статуса по чеку
     * @summary Получение статуса по чеку
     * @param {ApiPayApiGetPayReceiptStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPayReceiptStatus(requestParameters: ApiPayApiGetPayReceiptStatusRequest, options?: RawAxiosRequestConfig) {
        return ApiPayApiFp(this.configuration).getPayReceiptStatus(requestParameters.receiptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отправка чека в ОФД
     * @summary Отправка чека
     * @param {ApiPayApiSendPayReceiptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendPayReceipt(requestParameters: ApiPayApiSendPayReceiptRequest = {}, options?: RawAxiosRequestConfig) {
        return ApiPayApiFp(this.configuration).sendPayReceipt(requestParameters.payReceiptRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * B2cplApi - axios parameter creator
 */
export const B2cplApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Загрузка заявок на исходящий обзвон
         * @summary Загрузка заявок
         * @param {B2cplOrderCallRequest} [b2cplOrderCallRequest] Объект типа B2cplOrderCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderCall: async (b2cplOrderCallRequest?: B2cplOrderCallRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/b2cpl/call`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(b2cplOrderCallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * B2cplApi - functional programming interface
 */
export const B2cplApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = B2cplApiAxiosParamCreator(configuration)
    return {
        /**
         * Загрузка заявок на исходящий обзвон
         * @summary Загрузка заявок
         * @param {B2cplOrderCallRequest} [b2cplOrderCallRequest] Объект типа B2cplOrderCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrderCall(b2cplOrderCallRequest?: B2cplOrderCallRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOrderCall200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrderCall(b2cplOrderCallRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['B2cplApi.addOrderCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * B2cplApi - factory interface
 */
export const B2cplApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = B2cplApiFp(configuration)
    return {
        /**
         * Загрузка заявок на исходящий обзвон
         * @summary Загрузка заявок
         * @param {B2cplApiAddOrderCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderCall(requestParameters: B2cplApiAddOrderCallRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AddOrderCall200Response> {
            return localVarFp.addOrderCall(requestParameters.b2cplOrderCallRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrderCall operation in B2cplApi.
 */
export interface B2cplApiAddOrderCallRequest {
    /**
     * Объект типа B2cplOrderCallRequest
     */
    readonly b2cplOrderCallRequest?: B2cplOrderCallRequest
}

/**
 * B2cplApi - object-oriented interface
 */
export class B2cplApi extends BaseAPI {
    /**
     * Загрузка заявок на исходящий обзвон
     * @summary Загрузка заявок
     * @param {B2cplApiAddOrderCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addOrderCall(requestParameters: B2cplApiAddOrderCallRequest = {}, options?: RawAxiosRequestConfig) {
        return B2cplApiFp(this.configuration).addOrderCall(requestParameters.b2cplOrderCallRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingApi - axios parameter creator
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Баланс и остаток калькуляций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingBalanceGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/billing/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Баланс и остаток калькуляций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingBalanceGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingBalanceGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingBalanceGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingBalanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * 
         * @summary Баланс и остаток калькуляций
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingBalanceGet(options?: RawAxiosRequestConfig): AxiosPromise<BillingBalanceGet200Response> {
            return localVarFp.billingBalanceGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 */
export class BillingApi extends BaseAPI {
    /**
     * 
     * @summary Баланс и остаток калькуляций
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingBalanceGet(options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingBalanceGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BoxberryApi - axios parameter creator
 */
export const BoxberryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаление склада
         * @summary Удаление склада
         * @param {string} code Уникальный код склада
         * @param {string} [providerConnectId] ID подключения к СД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodeDelete: async (code: string, providerConnectId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('boxberryWarehouseCodeDelete', 'code', code)
            const localVarPath = `/boxberry/warehouse/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (providerConnectId !== undefined) {
                localVarQueryParameter['providerConnectId'] = providerConnectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение информации о складе
         * @summary Получение информации о складе
         * @param {string} code Уникальный код склада
         * @param {string} [providerConnectId] ID подключения к СД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodeGet: async (code: string, providerConnectId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('boxberryWarehouseCodeGet', 'code', code)
            const localVarPath = `/boxberry/warehouse/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (providerConnectId !== undefined) {
                localVarQueryParameter['providerConnectId'] = providerConnectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление склада
         * @summary Обновление склада
         * @param {string} code Уникальный код склада
         * @param {BoxberryWarehouseCodePutRequest} [boxberryWarehouseCodePutRequest] Объект типа WarehouseBoxberry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodePut: async (code: string, boxberryWarehouseCodePutRequest?: BoxberryWarehouseCodePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('boxberryWarehouseCodePut', 'code', code)
            const localVarPath = `/boxberry/warehouse/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boxberryWarehouseCodePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание склада
         * @summary Создание склада
         * @param {BoxberryWarehousePostRequest} [boxberryWarehousePostRequest] Объект типа WarehouseCreateBoxberry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehousePost: async (boxberryWarehousePostRequest?: BoxberryWarehousePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/boxberry/warehouse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boxberryWarehousePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoxberryApi - functional programming interface
 */
export const BoxberryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoxberryApiAxiosParamCreator(configuration)
    return {
        /**
         * Удаление склада
         * @summary Удаление склада
         * @param {string} code Уникальный код склада
         * @param {string} [providerConnectId] ID подключения к СД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boxberryWarehouseCodeDelete(code: string, providerConnectId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boxberryWarehouseCodeDelete(code, providerConnectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoxberryApi.boxberryWarehouseCodeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение информации о складе
         * @summary Получение информации о складе
         * @param {string} code Уникальный код склада
         * @param {string} [providerConnectId] ID подключения к СД
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boxberryWarehouseCodeGet(code: string, providerConnectId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WarehouseInfoBoxberry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boxberryWarehouseCodeGet(code, providerConnectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoxberryApi.boxberryWarehouseCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление склада
         * @summary Обновление склада
         * @param {string} code Уникальный код склада
         * @param {BoxberryWarehouseCodePutRequest} [boxberryWarehouseCodePutRequest] Объект типа WarehouseBoxberry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boxberryWarehouseCodePut(code: string, boxberryWarehouseCodePutRequest?: BoxberryWarehouseCodePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boxberryWarehouseCodePut(code, boxberryWarehouseCodePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoxberryApi.boxberryWarehouseCodePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создание склада
         * @summary Создание склада
         * @param {BoxberryWarehousePostRequest} [boxberryWarehousePostRequest] Объект типа WarehouseCreateBoxberry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boxberryWarehousePost(boxberryWarehousePostRequest?: BoxberryWarehousePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boxberryWarehousePost(boxberryWarehousePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoxberryApi.boxberryWarehousePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BoxberryApi - factory interface
 */
export const BoxberryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoxberryApiFp(configuration)
    return {
        /**
         * Удаление склада
         * @summary Удаление склада
         * @param {BoxberryApiBoxberryWarehouseCodeDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodeDelete(requestParameters: BoxberryApiBoxberryWarehouseCodeDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.boxberryWarehouseCodeDelete(requestParameters.code, requestParameters.providerConnectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение информации о складе
         * @summary Получение информации о складе
         * @param {BoxberryApiBoxberryWarehouseCodeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodeGet(requestParameters: BoxberryApiBoxberryWarehouseCodeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<WarehouseInfoBoxberry> {
            return localVarFp.boxberryWarehouseCodeGet(requestParameters.code, requestParameters.providerConnectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление склада
         * @summary Обновление склада
         * @param {BoxberryApiBoxberryWarehouseCodePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehouseCodePut(requestParameters: BoxberryApiBoxberryWarehouseCodePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.boxberryWarehouseCodePut(requestParameters.code, requestParameters.boxberryWarehouseCodePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание склада
         * @summary Создание склада
         * @param {BoxberryApiBoxberryWarehousePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boxberryWarehousePost(requestParameters: BoxberryApiBoxberryWarehousePostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.boxberryWarehousePost(requestParameters.boxberryWarehousePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for boxberryWarehouseCodeDelete operation in BoxberryApi.
 */
export interface BoxberryApiBoxberryWarehouseCodeDeleteRequest {
    /**
     * Уникальный код склада
     */
    readonly code: string

    /**
     * ID подключения к СД
     */
    readonly providerConnectId?: string
}

/**
 * Request parameters for boxberryWarehouseCodeGet operation in BoxberryApi.
 */
export interface BoxberryApiBoxberryWarehouseCodeGetRequest {
    /**
     * Уникальный код склада
     */
    readonly code: string

    /**
     * ID подключения к СД
     */
    readonly providerConnectId?: string
}

/**
 * Request parameters for boxberryWarehouseCodePut operation in BoxberryApi.
 */
export interface BoxberryApiBoxberryWarehouseCodePutRequest {
    /**
     * Уникальный код склада
     */
    readonly code: string

    /**
     * Объект типа WarehouseBoxberry
     */
    readonly boxberryWarehouseCodePutRequest?: BoxberryWarehouseCodePutRequest
}

/**
 * Request parameters for boxberryWarehousePost operation in BoxberryApi.
 */
export interface BoxberryApiBoxberryWarehousePostRequest {
    /**
     * Объект типа WarehouseCreateBoxberry
     */
    readonly boxberryWarehousePostRequest?: BoxberryWarehousePostRequest
}

/**
 * BoxberryApi - object-oriented interface
 */
export class BoxberryApi extends BaseAPI {
    /**
     * Удаление склада
     * @summary Удаление склада
     * @param {BoxberryApiBoxberryWarehouseCodeDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public boxberryWarehouseCodeDelete(requestParameters: BoxberryApiBoxberryWarehouseCodeDeleteRequest, options?: RawAxiosRequestConfig) {
        return BoxberryApiFp(this.configuration).boxberryWarehouseCodeDelete(requestParameters.code, requestParameters.providerConnectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение информации о складе
     * @summary Получение информации о складе
     * @param {BoxberryApiBoxberryWarehouseCodeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public boxberryWarehouseCodeGet(requestParameters: BoxberryApiBoxberryWarehouseCodeGetRequest, options?: RawAxiosRequestConfig) {
        return BoxberryApiFp(this.configuration).boxberryWarehouseCodeGet(requestParameters.code, requestParameters.providerConnectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление склада
     * @summary Обновление склада
     * @param {BoxberryApiBoxberryWarehouseCodePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public boxberryWarehouseCodePut(requestParameters: BoxberryApiBoxberryWarehouseCodePutRequest, options?: RawAxiosRequestConfig) {
        return BoxberryApiFp(this.configuration).boxberryWarehouseCodePut(requestParameters.code, requestParameters.boxberryWarehouseCodePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание склада
     * @summary Создание склада
     * @param {BoxberryApiBoxberryWarehousePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public boxberryWarehousePost(requestParameters: BoxberryApiBoxberryWarehousePostRequest = {}, options?: RawAxiosRequestConfig) {
        return BoxberryApiFp(this.configuration).boxberryWarehousePost(requestParameters.boxberryWarehousePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalculatorApi - axios parameter creator
 */
export const CalculatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Запрашивает у СД доступные интервалы
         * @summary Интервалы доставки
         * @param {CalculatorIntervalsRequest} [calculatorIntervalsRequest] Объект типа CalculatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculatorIntervalsPost: async (calculatorIntervalsRequest?: CalculatorIntervalsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calculator/intervals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculatorIntervalsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Рассчитывает стоимость доставки
         * @summary Расчёт стоимости доставки
         * @param {CalculatorRequest} [calculatorRequest] Объект типа CalculatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculator: async (calculatorRequest?: CalculatorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calculator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(calculatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalculatorApi - functional programming interface
 */
export const CalculatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalculatorApiAxiosParamCreator(configuration)
    return {
        /**
         * Запрашивает у СД доступные интервалы
         * @summary Интервалы доставки
         * @param {CalculatorIntervalsRequest} [calculatorIntervalsRequest] Объект типа CalculatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculatorIntervalsPost(calculatorIntervalsRequest?: CalculatorIntervalsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculatorIntervalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculatorIntervalsPost(calculatorIntervalsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalculatorApi.calculatorIntervalsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Рассчитывает стоимость доставки
         * @summary Расчёт стоимости доставки
         * @param {CalculatorRequest} [calculatorRequest] Объект типа CalculatorRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCalculator(calculatorRequest?: CalculatorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCalculator200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCalculator(calculatorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalculatorApi.getCalculator']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalculatorApi - factory interface
 */
export const CalculatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalculatorApiFp(configuration)
    return {
        /**
         * Запрашивает у СД доступные интервалы
         * @summary Интервалы доставки
         * @param {CalculatorApiCalculatorIntervalsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculatorIntervalsPost(requestParameters: CalculatorApiCalculatorIntervalsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CalculatorIntervalsResponse> {
            return localVarFp.calculatorIntervalsPost(requestParameters.calculatorIntervalsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Рассчитывает стоимость доставки
         * @summary Расчёт стоимости доставки
         * @param {CalculatorApiGetCalculatorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCalculator(requestParameters: CalculatorApiGetCalculatorRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetCalculator200Response> {
            return localVarFp.getCalculator(requestParameters.calculatorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for calculatorIntervalsPost operation in CalculatorApi.
 */
export interface CalculatorApiCalculatorIntervalsPostRequest {
    /**
     * Объект типа CalculatorRequest
     */
    readonly calculatorIntervalsRequest?: CalculatorIntervalsRequest
}

/**
 * Request parameters for getCalculator operation in CalculatorApi.
 */
export interface CalculatorApiGetCalculatorRequest {
    /**
     * Объект типа CalculatorRequest
     */
    readonly calculatorRequest?: CalculatorRequest
}

/**
 * CalculatorApi - object-oriented interface
 */
export class CalculatorApi extends BaseAPI {
    /**
     * Запрашивает у СД доступные интервалы
     * @summary Интервалы доставки
     * @param {CalculatorApiCalculatorIntervalsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public calculatorIntervalsPost(requestParameters: CalculatorApiCalculatorIntervalsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CalculatorApiFp(this.configuration).calculatorIntervalsPost(requestParameters.calculatorIntervalsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Рассчитывает стоимость доставки
     * @summary Расчёт стоимости доставки
     * @param {CalculatorApiGetCalculatorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCalculator(requestParameters: CalculatorApiGetCalculatorRequest = {}, options?: RawAxiosRequestConfig) {
        return CalculatorApiFp(this.configuration).getCalculator(requestParameters.calculatorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConnectionsApi - axios parameter creator
 */
export const ConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверяет авторизационные данные к системе службы доставки и создает подключение.
         * @summary Создание подключения к службе доставки
         * @param {Connection} [connection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection: async (connection?: Connection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подключение помечается удаленным. Можно будет восстановить через службу поддержки.
         * @summary Удаление подключения службы доставки
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConnection', 'id', id)
            const localVarPath = `/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает подключение службы доставки.
         * @summary Получение подключения службы доставки
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConnection', 'id', id)
            const localVarPath = `/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает постраничный список подключений пользователя
         * @summary Получение списка подключений пользователя
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {string} [filter] JSON-фильтр. Фильтрация по полям объектов. Например, чтобы отфильтровать по пользователю, нужно передать filter&#x3D;{\&quot;userId\&quot;:\&quot;123\&quot;,\&quot;providerKey\&quot;:\&quot;cdek\&quot;}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListConnections: async (offset?: number, limit?: number, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновляет подключение к службе доставки. При обновлении проверяет авторизационные данные в API службы доставки.
         * @summary Обновление подключения службы доставки
         * @param {string} id 
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnection: async (id: string, connection: Connection, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readConnection', 'id', id)
            // verify required parameter 'connection' is not null or undefined
            assertParamExists('readConnection', 'connection', connection)
            const localVarPath = `/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Возвращает набор полей каждой службы доставки, которые возможно заполнить для создания\\обновления подключения (connectParams)  Метод возвращает схему подключения к службе доставки. Обычно используется для отрисовки формы создания подключения на стороне маркетплейса / модуля / агрегатора. Т.е. метод необходим если вам нужно дать возможность своим пользователям создавать подключения, иначе лучше это делать через наш личный кабинет.  Массив fields - это список полей connectParams в методе [createConnection](#/connections/createConnection)  * *code* - это название поля в json * *type* - это тип значения * *values* - это массив с возможными значениями для поля. * *multiple* - поле может принимать несколько значений, т.е. значение поля является массивом. * *required* - поле обязательно для передачи  Сценарий: 1. Получаете схемы всех служб. 2. По схеме отрисовываете форму для нужной службы доставки. 3. Формируете connectParams собранный из этой формы. 4. Создаете подключение.  Пример: 1. Получили схему Деливери.Клаб ```json {    \"providerKey\": \"d-club\",    \"fields\": [      {        \"code\": \"login\",        \"name\": \"Логин\",        \"description\": \"Логин\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      },      {        \"code\": \"password\",        \"name\": \"Пароль\",        \"description\": \"Пароль\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      }    ]  } ``` 2. Создаем [подключение](#/connections/createConnection) на основе схемы. Схема это набор полей в параметре connectParams: ```json \"connectParams\": {   \"login\": \"mylogin\",   \"password\": \"mypassword\" } ``` 3. В итоге получаем такую структуру для создания подключения: ```json {   \"name\": \"Основное подключение к службе доставки\",   \"providerKey\": \"d-club\",   \"insuranceRate\": 0,   \"cashServiceRate\": 0,   \"connectParams\": {     \"login\": \"mylogin\",     \"password\": \"mypassword\"   },   \"isUseBaseConnect\": 0 } ``` 
         * @summary Получение схемы подключений служб доставки
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {string} [providerKey] Фильтрации схемы по службе доставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSchemasConnection: async (offset?: number, limit?: number, providerKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/connections/schemas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (providerKey !== undefined) {
                localVarQueryParameter['providerKey'] = providerKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConnectionsApi - functional programming interface
 */
export const ConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверяет авторизационные данные к системе службы доставки и создает подключение.
         * @summary Создание подключения к службе доставки
         * @param {Connection} [connection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnection(connection?: Connection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnection(connection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.createConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Подключение помечается удаленным. Можно будет восстановить через службу поддержки.
         * @summary Удаление подключения службы доставки
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConnection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConnection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.deleteConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает подключение службы доставки.
         * @summary Получение подключения службы доставки
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConnection(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConnection(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает постраничный список подключений пользователя
         * @summary Получение списка подключений пользователя
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {string} [filter] JSON-фильтр. Фильтрация по полям объектов. Например, чтобы отфильтровать по пользователю, нужно передать filter&#x3D;{\&quot;userId\&quot;:\&quot;123\&quot;,\&quot;providerKey\&quot;:\&quot;cdek\&quot;}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListConnections(offset?: number, limit?: number, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListConnections(offset, limit, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.getListConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновляет подключение к службе доставки. При обновлении проверяет авторизационные данные в API службы доставки.
         * @summary Обновление подключения службы доставки
         * @param {string} id 
         * @param {Connection} connection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readConnection(id: string, connection: Connection, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readConnection(id, connection, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.readConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Возвращает набор полей каждой службы доставки, которые возможно заполнить для создания\\обновления подключения (connectParams)  Метод возвращает схему подключения к службе доставки. Обычно используется для отрисовки формы создания подключения на стороне маркетплейса / модуля / агрегатора. Т.е. метод необходим если вам нужно дать возможность своим пользователям создавать подключения, иначе лучше это делать через наш личный кабинет.  Массив fields - это список полей connectParams в методе [createConnection](#/connections/createConnection)  * *code* - это название поля в json * *type* - это тип значения * *values* - это массив с возможными значениями для поля. * *multiple* - поле может принимать несколько значений, т.е. значение поля является массивом. * *required* - поле обязательно для передачи  Сценарий: 1. Получаете схемы всех служб. 2. По схеме отрисовываете форму для нужной службы доставки. 3. Формируете connectParams собранный из этой формы. 4. Создаете подключение.  Пример: 1. Получили схему Деливери.Клаб ```json {    \"providerKey\": \"d-club\",    \"fields\": [      {        \"code\": \"login\",        \"name\": \"Логин\",        \"description\": \"Логин\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      },      {        \"code\": \"password\",        \"name\": \"Пароль\",        \"description\": \"Пароль\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      }    ]  } ``` 2. Создаем [подключение](#/connections/createConnection) на основе схемы. Схема это набор полей в параметре connectParams: ```json \"connectParams\": {   \"login\": \"mylogin\",   \"password\": \"mypassword\" } ``` 3. В итоге получаем такую структуру для создания подключения: ```json {   \"name\": \"Основное подключение к службе доставки\",   \"providerKey\": \"d-club\",   \"insuranceRate\": 0,   \"cashServiceRate\": 0,   \"connectParams\": {     \"login\": \"mylogin\",     \"password\": \"mypassword\"   },   \"isUseBaseConnect\": 0 } ``` 
         * @summary Получение схемы подключений служб доставки
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {string} [providerKey] Фильтрации схемы по службе доставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readSchemasConnection(offset?: number, limit?: number, providerKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SchemasConnectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readSchemasConnection(offset, limit, providerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConnectionsApi.readSchemasConnection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConnectionsApi - factory interface
 */
export const ConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConnectionsApiFp(configuration)
    return {
        /**
         * Проверяет авторизационные данные к системе службы доставки и создает подключение.
         * @summary Создание подключения к службе доставки
         * @param {ConnectionsApiCreateConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnection(requestParameters: ConnectionsApiCreateConnectionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Connection> {
            return localVarFp.createConnection(requestParameters.connection, options).then((request) => request(axios, basePath));
        },
        /**
         * Подключение помечается удаленным. Можно будет восстановить через службу поддержки.
         * @summary Удаление подключения службы доставки
         * @param {ConnectionsApiDeleteConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConnection(requestParameters: ConnectionsApiDeleteConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteConnection(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает подключение службы доставки.
         * @summary Получение подключения службы доставки
         * @param {ConnectionsApiGetConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnection(requestParameters: ConnectionsApiGetConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Connection> {
            return localVarFp.getConnection(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает постраничный список подключений пользователя
         * @summary Получение списка подключений пользователя
         * @param {ConnectionsApiGetListConnectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListConnections(requestParameters: ConnectionsApiGetListConnectionsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ListConnectionResponse> {
            return localVarFp.getListConnections(requestParameters.offset, requestParameters.limit, requestParameters.filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновляет подключение к службе доставки. При обновлении проверяет авторизационные данные в API службы доставки.
         * @summary Обновление подключения службы доставки
         * @param {ConnectionsApiReadConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readConnection(requestParameters: ConnectionsApiReadConnectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Connection> {
            return localVarFp.readConnection(requestParameters.id, requestParameters.connection, options).then((request) => request(axios, basePath));
        },
        /**
         * Возвращает набор полей каждой службы доставки, которые возможно заполнить для создания\\обновления подключения (connectParams)  Метод возвращает схему подключения к службе доставки. Обычно используется для отрисовки формы создания подключения на стороне маркетплейса / модуля / агрегатора. Т.е. метод необходим если вам нужно дать возможность своим пользователям создавать подключения, иначе лучше это делать через наш личный кабинет.  Массив fields - это список полей connectParams в методе [createConnection](#/connections/createConnection)  * *code* - это название поля в json * *type* - это тип значения * *values* - это массив с возможными значениями для поля. * *multiple* - поле может принимать несколько значений, т.е. значение поля является массивом. * *required* - поле обязательно для передачи  Сценарий: 1. Получаете схемы всех служб. 2. По схеме отрисовываете форму для нужной службы доставки. 3. Формируете connectParams собранный из этой формы. 4. Создаете подключение.  Пример: 1. Получили схему Деливери.Клаб ```json {    \"providerKey\": \"d-club\",    \"fields\": [      {        \"code\": \"login\",        \"name\": \"Логин\",        \"description\": \"Логин\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      },      {        \"code\": \"password\",        \"name\": \"Пароль\",        \"description\": \"Пароль\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      }    ]  } ``` 2. Создаем [подключение](#/connections/createConnection) на основе схемы. Схема это набор полей в параметре connectParams: ```json \"connectParams\": {   \"login\": \"mylogin\",   \"password\": \"mypassword\" } ``` 3. В итоге получаем такую структуру для создания подключения: ```json {   \"name\": \"Основное подключение к службе доставки\",   \"providerKey\": \"d-club\",   \"insuranceRate\": 0,   \"cashServiceRate\": 0,   \"connectParams\": {     \"login\": \"mylogin\",     \"password\": \"mypassword\"   },   \"isUseBaseConnect\": 0 } ``` 
         * @summary Получение схемы подключений служб доставки
         * @param {ConnectionsApiReadSchemasConnectionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readSchemasConnection(requestParameters: ConnectionsApiReadSchemasConnectionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SchemasConnectionResponse> {
            return localVarFp.readSchemasConnection(requestParameters.offset, requestParameters.limit, requestParameters.providerKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createConnection operation in ConnectionsApi.
 */
export interface ConnectionsApiCreateConnectionRequest {
    readonly connection?: Connection
}

/**
 * Request parameters for deleteConnection operation in ConnectionsApi.
 */
export interface ConnectionsApiDeleteConnectionRequest {
    readonly id: string
}

/**
 * Request parameters for getConnection operation in ConnectionsApi.
 */
export interface ConnectionsApiGetConnectionRequest {
    readonly id: string
}

/**
 * Request parameters for getListConnections operation in ConnectionsApi.
 */
export interface ConnectionsApiGetListConnectionsRequest {
    /**
     * Minimum - 0, Maximum - 5000
     */
    readonly offset?: number

    /**
     * Minimum - 1, Maximum - 100
     */
    readonly limit?: number

    /**
     * JSON-фильтр. Фильтрация по полям объектов. Например, чтобы отфильтровать по пользователю, нужно передать filter&#x3D;{\&quot;userId\&quot;:\&quot;123\&quot;,\&quot;providerKey\&quot;:\&quot;cdek\&quot;}
     */
    readonly filter?: string
}

/**
 * Request parameters for readConnection operation in ConnectionsApi.
 */
export interface ConnectionsApiReadConnectionRequest {
    readonly id: string

    readonly connection: Connection
}

/**
 * Request parameters for readSchemasConnection operation in ConnectionsApi.
 */
export interface ConnectionsApiReadSchemasConnectionRequest {
    /**
     * Minimum - 0, Maximum - 5000
     */
    readonly offset?: number

    /**
     * Minimum - 1, Maximum - 100
     */
    readonly limit?: number

    /**
     * Фильтрации схемы по службе доставки
     */
    readonly providerKey?: string
}

/**
 * ConnectionsApi - object-oriented interface
 */
export class ConnectionsApi extends BaseAPI {
    /**
     * Проверяет авторизационные данные к системе службы доставки и создает подключение.
     * @summary Создание подключения к службе доставки
     * @param {ConnectionsApiCreateConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createConnection(requestParameters: ConnectionsApiCreateConnectionRequest = {}, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).createConnection(requestParameters.connection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Подключение помечается удаленным. Можно будет восстановить через службу поддержки.
     * @summary Удаление подключения службы доставки
     * @param {ConnectionsApiDeleteConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteConnection(requestParameters: ConnectionsApiDeleteConnectionRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).deleteConnection(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает подключение службы доставки.
     * @summary Получение подключения службы доставки
     * @param {ConnectionsApiGetConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getConnection(requestParameters: ConnectionsApiGetConnectionRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getConnection(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает постраничный список подключений пользователя
     * @summary Получение списка подключений пользователя
     * @param {ConnectionsApiGetListConnectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListConnections(requestParameters: ConnectionsApiGetListConnectionsRequest = {}, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).getListConnections(requestParameters.offset, requestParameters.limit, requestParameters.filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновляет подключение к службе доставки. При обновлении проверяет авторизационные данные в API службы доставки.
     * @summary Обновление подключения службы доставки
     * @param {ConnectionsApiReadConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readConnection(requestParameters: ConnectionsApiReadConnectionRequest, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).readConnection(requestParameters.id, requestParameters.connection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Возвращает набор полей каждой службы доставки, которые возможно заполнить для создания\\обновления подключения (connectParams)  Метод возвращает схему подключения к службе доставки. Обычно используется для отрисовки формы создания подключения на стороне маркетплейса / модуля / агрегатора. Т.е. метод необходим если вам нужно дать возможность своим пользователям создавать подключения, иначе лучше это делать через наш личный кабинет.  Массив fields - это список полей connectParams в методе [createConnection](#/connections/createConnection)  * *code* - это название поля в json * *type* - это тип значения * *values* - это массив с возможными значениями для поля. * *multiple* - поле может принимать несколько значений, т.е. значение поля является массивом. * *required* - поле обязательно для передачи  Сценарий: 1. Получаете схемы всех служб. 2. По схеме отрисовываете форму для нужной службы доставки. 3. Формируете connectParams собранный из этой формы. 4. Создаете подключение.  Пример: 1. Получили схему Деливери.Клаб ```json {    \"providerKey\": \"d-club\",    \"fields\": [      {        \"code\": \"login\",        \"name\": \"Логин\",        \"description\": \"Логин\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      },      {        \"code\": \"password\",        \"name\": \"Пароль\",        \"description\": \"Пароль\",        \"type\": \"string\",        \"required\": true,        \"multiple\": false,        \"values\": []      }    ]  } ``` 2. Создаем [подключение](#/connections/createConnection) на основе схемы. Схема это набор полей в параметре connectParams: ```json \"connectParams\": {   \"login\": \"mylogin\",   \"password\": \"mypassword\" } ``` 3. В итоге получаем такую структуру для создания подключения: ```json {   \"name\": \"Основное подключение к службе доставки\",   \"providerKey\": \"d-club\",   \"insuranceRate\": 0,   \"cashServiceRate\": 0,   \"connectParams\": {     \"login\": \"mylogin\",     \"password\": \"mypassword\"   },   \"isUseBaseConnect\": 0 } ``` 
     * @summary Получение схемы подключений служб доставки
     * @param {ConnectionsApiReadSchemasConnectionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readSchemasConnection(requestParameters: ConnectionsApiReadSchemasConnectionRequest = {}, options?: RawAxiosRequestConfig) {
        return ConnectionsApiFp(this.configuration).readSchemasConnection(requestParameters.offset, requestParameters.limit, requestParameters.providerKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CourierCallApi - axios parameter creator
 */
export const CourierCallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Отмена заявки на вызов курьера
         * @summary Отмена заявки на вызов курьера
         * @param {number} courierCallId ID заявки на вызов курьера, которую необходимо отменить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCourierCall: async (courierCallId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courierCallId' is not null or undefined
            assertParamExists('cancelCourierCall', 'courierCallId', courierCallId)
            const localVarPath = `/courierCall/{courierCallId}/cancel`
                .replace(`{${"courierCallId"}}`, encodeURIComponent(String(courierCallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание заявки на вызов курьера
         * @summary Создание заявки на вызов курьера
         * @param {CourierCallRequest} [courierCallRequest] Объект типа CourierCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courierCall: async (courierCallRequest?: CourierCallRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/courierCall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courierCallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourierCallApi - functional programming interface
 */
export const CourierCallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourierCallApiAxiosParamCreator(configuration)
    return {
        /**
         * Отмена заявки на вызов курьера
         * @summary Отмена заявки на вызов курьера
         * @param {number} courierCallId ID заявки на вызов курьера, которую необходимо отменить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelCourierCall(courierCallId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelCourierCallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelCourierCall(courierCallId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourierCallApi.cancelCourierCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создание заявки на вызов курьера
         * @summary Создание заявки на вызов курьера
         * @param {CourierCallRequest} [courierCallRequest] Объект типа CourierCallRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courierCall(courierCallRequest?: CourierCallRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourierCallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courierCall(courierCallRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourierCallApi.courierCall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourierCallApi - factory interface
 */
export const CourierCallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourierCallApiFp(configuration)
    return {
        /**
         * Отмена заявки на вызов курьера
         * @summary Отмена заявки на вызов курьера
         * @param {CourierCallApiCancelCourierCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCourierCall(requestParameters: CourierCallApiCancelCourierCallRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelCourierCallResponse> {
            return localVarFp.cancelCourierCall(requestParameters.courierCallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание заявки на вызов курьера
         * @summary Создание заявки на вызов курьера
         * @param {CourierCallApiCourierCallRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courierCall(requestParameters: CourierCallApiCourierCallRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CourierCallResponse> {
            return localVarFp.courierCall(requestParameters.courierCallRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancelCourierCall operation in CourierCallApi.
 */
export interface CourierCallApiCancelCourierCallRequest {
    /**
     * ID заявки на вызов курьера, которую необходимо отменить
     */
    readonly courierCallId: number
}

/**
 * Request parameters for courierCall operation in CourierCallApi.
 */
export interface CourierCallApiCourierCallRequest {
    /**
     * Объект типа CourierCallRequest
     */
    readonly courierCallRequest?: CourierCallRequest
}

/**
 * CourierCallApi - object-oriented interface
 */
export class CourierCallApi extends BaseAPI {
    /**
     * Отмена заявки на вызов курьера
     * @summary Отмена заявки на вызов курьера
     * @param {CourierCallApiCancelCourierCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelCourierCall(requestParameters: CourierCallApiCancelCourierCallRequest, options?: RawAxiosRequestConfig) {
        return CourierCallApiFp(this.configuration).cancelCourierCall(requestParameters.courierCallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание заявки на вызов курьера
     * @summary Создание заявки на вызов курьера
     * @param {CourierCallApiCourierCallRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public courierCall(requestParameters: CourierCallApiCourierCallRequest = {}, options?: RawAxiosRequestConfig) {
        return CourierCallApiFp(this.configuration).courierCall(requestParameters.courierCallRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CseApi - axios parameter creator
 */
export const CseApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Функция сохраняет нового контрагента в справочнике «Контрагенты» и создаёт «Расчетный счет» для этого контрагента в системе «Карго».
         * @summary Передача данных контрагента - владельца товара
         * @param {CseSaveOwnerOfTheGoodsPostRequest} [cseSaveOwnerOfTheGoodsPostRequest] Объект типа SaveOwnerOfTheGoods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cseSaveOwnerOfTheGoodsPost: async (cseSaveOwnerOfTheGoodsPostRequest?: CseSaveOwnerOfTheGoodsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cse/saveOwnerOfTheGoods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cseSaveOwnerOfTheGoodsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CseApi - functional programming interface
 */
export const CseApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CseApiAxiosParamCreator(configuration)
    return {
        /**
         * Функция сохраняет нового контрагента в справочнике «Контрагенты» и создаёт «Расчетный счет» для этого контрагента в системе «Карго».
         * @summary Передача данных контрагента - владельца товара
         * @param {CseSaveOwnerOfTheGoodsPostRequest} [cseSaveOwnerOfTheGoodsPostRequest] Объект типа SaveOwnerOfTheGoods
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cseSaveOwnerOfTheGoodsPost(cseSaveOwnerOfTheGoodsPostRequest?: CseSaveOwnerOfTheGoodsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cseSaveOwnerOfTheGoodsPost(cseSaveOwnerOfTheGoodsPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CseApi.cseSaveOwnerOfTheGoodsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CseApi - factory interface
 */
export const CseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CseApiFp(configuration)
    return {
        /**
         * Функция сохраняет нового контрагента в справочнике «Контрагенты» и создаёт «Расчетный счет» для этого контрагента в системе «Карго».
         * @summary Передача данных контрагента - владельца товара
         * @param {CseApiCseSaveOwnerOfTheGoodsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cseSaveOwnerOfTheGoodsPost(requestParameters: CseApiCseSaveOwnerOfTheGoodsPostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.cseSaveOwnerOfTheGoodsPost(requestParameters.cseSaveOwnerOfTheGoodsPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cseSaveOwnerOfTheGoodsPost operation in CseApi.
 */
export interface CseApiCseSaveOwnerOfTheGoodsPostRequest {
    /**
     * Объект типа SaveOwnerOfTheGoods
     */
    readonly cseSaveOwnerOfTheGoodsPostRequest?: CseSaveOwnerOfTheGoodsPostRequest
}

/**
 * CseApi - object-oriented interface
 */
export class CseApi extends BaseAPI {
    /**
     * Функция сохраняет нового контрагента в справочнике «Контрагенты» и создаёт «Расчетный счет» для этого контрагента в системе «Карго».
     * @summary Передача данных контрагента - владельца товара
     * @param {CseApiCseSaveOwnerOfTheGoodsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cseSaveOwnerOfTheGoodsPost(requestParameters: CseApiCseSaveOwnerOfTheGoodsPostRequest = {}, options?: RawAxiosRequestConfig) {
        return CseApiFp(this.configuration).cseSaveOwnerOfTheGoodsPost(requestParameters.cseSaveOwnerOfTheGoodsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DpdApi - axios parameter creator
 */
export const DpdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Соединить заказ с заявкой на приезд курьера
         * @summary Соединить заказ с заявкой на приезд курьера
         * @param {DpdBindPreorderPickupRequest} [dpdBindPreorderPickupRequest] Объект типа DpdBindPreorderPickupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindPreorderPickup: async (dpdBindPreorderPickupRequest?: DpdBindPreorderPickupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dpd/bindPreorderPickup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dpdBindPreorderPickupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание кода адреса
         * @summary Создание кода адреса
         * @param {CreateAddressCodeRequest} [createAddressCodeRequest] Объект типа CreateAddressCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddressCode: async (createAddressCodeRequest?: CreateAddressCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dpd/createAddressCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление кода адреса
         * @summary Обновление кода адреса
         * @param {CreateAddressCodeRequest} [createAddressCodeRequest] Объект типа CreateAddressCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddressCode: async (createAddressCodeRequest?: CreateAddressCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dpd/updateAddressCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAddressCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DpdApi - functional programming interface
 */
export const DpdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DpdApiAxiosParamCreator(configuration)
    return {
        /**
         * Соединить заказ с заявкой на приезд курьера
         * @summary Соединить заказ с заявкой на приезд курьера
         * @param {DpdBindPreorderPickupRequest} [dpdBindPreorderPickupRequest] Объект типа DpdBindPreorderPickupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bindPreorderPickup(dpdBindPreorderPickupRequest?: DpdBindPreorderPickupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DpdBindPreorderPickupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bindPreorderPickup(dpdBindPreorderPickupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DpdApi.bindPreorderPickup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создание кода адреса
         * @summary Создание кода адреса
         * @param {CreateAddressCodeRequest} [createAddressCodeRequest] Объект типа CreateAddressCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddressCode(createAddressCodeRequest?: CreateAddressCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddressCode(createAddressCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DpdApi.createAddressCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление кода адреса
         * @summary Обновление кода адреса
         * @param {CreateAddressCodeRequest} [createAddressCodeRequest] Объект типа CreateAddressCodeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddressCode(createAddressCodeRequest?: CreateAddressCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAddressCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddressCode(createAddressCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DpdApi.updateAddressCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DpdApi - factory interface
 */
export const DpdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DpdApiFp(configuration)
    return {
        /**
         * Соединить заказ с заявкой на приезд курьера
         * @summary Соединить заказ с заявкой на приезд курьера
         * @param {DpdApiBindPreorderPickupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bindPreorderPickup(requestParameters: DpdApiBindPreorderPickupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DpdBindPreorderPickupResponse> {
            return localVarFp.bindPreorderPickup(requestParameters.dpdBindPreorderPickupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание кода адреса
         * @summary Создание кода адреса
         * @param {DpdApiCreateAddressCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddressCode(requestParameters: DpdApiCreateAddressCodeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateAddressCodeResponse> {
            return localVarFp.createAddressCode(requestParameters.createAddressCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление кода адреса
         * @summary Обновление кода адреса
         * @param {DpdApiUpdateAddressCodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddressCode(requestParameters: DpdApiUpdateAddressCodeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateAddressCodeResponse> {
            return localVarFp.updateAddressCode(requestParameters.createAddressCodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for bindPreorderPickup operation in DpdApi.
 */
export interface DpdApiBindPreorderPickupRequest {
    /**
     * Объект типа DpdBindPreorderPickupRequest
     */
    readonly dpdBindPreorderPickupRequest?: DpdBindPreorderPickupRequest
}

/**
 * Request parameters for createAddressCode operation in DpdApi.
 */
export interface DpdApiCreateAddressCodeRequest {
    /**
     * Объект типа CreateAddressCodeRequest
     */
    readonly createAddressCodeRequest?: CreateAddressCodeRequest
}

/**
 * Request parameters for updateAddressCode operation in DpdApi.
 */
export interface DpdApiUpdateAddressCodeRequest {
    /**
     * Объект типа CreateAddressCodeRequest
     */
    readonly createAddressCodeRequest?: CreateAddressCodeRequest
}

/**
 * DpdApi - object-oriented interface
 */
export class DpdApi extends BaseAPI {
    /**
     * Соединить заказ с заявкой на приезд курьера
     * @summary Соединить заказ с заявкой на приезд курьера
     * @param {DpdApiBindPreorderPickupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bindPreorderPickup(requestParameters: DpdApiBindPreorderPickupRequest = {}, options?: RawAxiosRequestConfig) {
        return DpdApiFp(this.configuration).bindPreorderPickup(requestParameters.dpdBindPreorderPickupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание кода адреса
     * @summary Создание кода адреса
     * @param {DpdApiCreateAddressCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createAddressCode(requestParameters: DpdApiCreateAddressCodeRequest = {}, options?: RawAxiosRequestConfig) {
        return DpdApiFp(this.configuration).createAddressCode(requestParameters.createAddressCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление кода адреса
     * @summary Обновление кода адреса
     * @param {DpdApiUpdateAddressCodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateAddressCode(requestParameters: DpdApiUpdateAddressCodeRequest = {}, options?: RawAxiosRequestConfig) {
        return DpdApiFp(this.configuration).updateAddressCode(requestParameters.createAddressCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExternalTrackingApi - axios parameter creator
 */
export const ExternalTrackingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Удаление трекинга заказа
         * @summary Удаление трекинга заказа
         * @param {string} orderId ID трекинга
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTrackingOrdersOrderIdDelete: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('externalTrackingOrdersOrderIdDelete', 'orderId', orderId)
            const localVarPath = `/externalTracking/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отслеживание заказов, созданных не через ApiShip. Поддерживаемые службы доставки: 5POST, Boxberry, BXB, КСЭ, Logsis,Major Express, Почта России
         * @summary Трекинг внешних заказов
         * @param {Array<ExternalTrackingOrdersRequestInner>} externalTrackingOrdersRequestInner Объект типа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTrackingOrdersPost: async (externalTrackingOrdersRequestInner: Array<ExternalTrackingOrdersRequestInner>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalTrackingOrdersRequestInner' is not null or undefined
            assertParamExists('externalTrackingOrdersPost', 'externalTrackingOrdersRequestInner', externalTrackingOrdersRequestInner)
            const localVarPath = `/externalTracking/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(externalTrackingOrdersRequestInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalTrackingApi - functional programming interface
 */
export const ExternalTrackingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalTrackingApiAxiosParamCreator(configuration)
    return {
        /**
         * Удаление трекинга заказа
         * @summary Удаление трекинга заказа
         * @param {string} orderId ID трекинга
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalTrackingOrdersOrderIdDelete(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalTrackingDeleteOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalTrackingOrdersOrderIdDelete(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalTrackingApi.externalTrackingOrdersOrderIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Отслеживание заказов, созданных не через ApiShip. Поддерживаемые службы доставки: 5POST, Boxberry, BXB, КСЭ, Logsis,Major Express, Почта России
         * @summary Трекинг внешних заказов
         * @param {Array<ExternalTrackingOrdersRequestInner>} externalTrackingOrdersRequestInner Объект типа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalTrackingOrdersPost(externalTrackingOrdersRequestInner: Array<ExternalTrackingOrdersRequestInner>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExternalTrackingOrderResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalTrackingOrdersPost(externalTrackingOrdersRequestInner, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalTrackingApi.externalTrackingOrdersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalTrackingApi - factory interface
 */
export const ExternalTrackingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalTrackingApiFp(configuration)
    return {
        /**
         * Удаление трекинга заказа
         * @summary Удаление трекинга заказа
         * @param {ExternalTrackingApiExternalTrackingOrdersOrderIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTrackingOrdersOrderIdDelete(requestParameters: ExternalTrackingApiExternalTrackingOrdersOrderIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExternalTrackingDeleteOrderResponse> {
            return localVarFp.externalTrackingOrdersOrderIdDelete(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Отслеживание заказов, созданных не через ApiShip. Поддерживаемые службы доставки: 5POST, Boxberry, BXB, КСЭ, Logsis,Major Express, Почта России
         * @summary Трекинг внешних заказов
         * @param {ExternalTrackingApiExternalTrackingOrdersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalTrackingOrdersPost(requestParameters: ExternalTrackingApiExternalTrackingOrdersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ExternalTrackingOrderResponseInner>> {
            return localVarFp.externalTrackingOrdersPost(requestParameters.externalTrackingOrdersRequestInner, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for externalTrackingOrdersOrderIdDelete operation in ExternalTrackingApi.
 */
export interface ExternalTrackingApiExternalTrackingOrdersOrderIdDeleteRequest {
    /**
     * ID трекинга
     */
    readonly orderId: string
}

/**
 * Request parameters for externalTrackingOrdersPost operation in ExternalTrackingApi.
 */
export interface ExternalTrackingApiExternalTrackingOrdersPostRequest {
    /**
     * Объект типа
     */
    readonly externalTrackingOrdersRequestInner: Array<ExternalTrackingOrdersRequestInner>
}

/**
 * ExternalTrackingApi - object-oriented interface
 */
export class ExternalTrackingApi extends BaseAPI {
    /**
     * Удаление трекинга заказа
     * @summary Удаление трекинга заказа
     * @param {ExternalTrackingApiExternalTrackingOrdersOrderIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public externalTrackingOrdersOrderIdDelete(requestParameters: ExternalTrackingApiExternalTrackingOrdersOrderIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ExternalTrackingApiFp(this.configuration).externalTrackingOrdersOrderIdDelete(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отслеживание заказов, созданных не через ApiShip. Поддерживаемые службы доставки: 5POST, Boxberry, BXB, КСЭ, Logsis,Major Express, Почта России
     * @summary Трекинг внешних заказов
     * @param {ExternalTrackingApiExternalTrackingOrdersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public externalTrackingOrdersPost(requestParameters: ExternalTrackingApiExternalTrackingOrdersPostRequest, options?: RawAxiosRequestConfig) {
        return ExternalTrackingApiFp(this.configuration).externalTrackingOrdersPost(requestParameters.externalTrackingOrdersRequestInner, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ListsApi - axios parameter creator
 */
export const ListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение всех параметров подключения к службам доставки
         * @summary Получение всех параметров подключения к службам доставки
         * @param {number} [limit] Лимит выборки
         * @param {number} [offset] Смещение выборки
         * @param {string} [_with] Список связанных данных, которые возвращаются в ответе. Возможные значения - company
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllParams: async (limit?: number, offset?: number, _with?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providers/connections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка городов b2cpl
         * @summary Получение списка городов b2cpl
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, region, residence, zipFirst, zipLast, transportDays, flagCourier, flagPvz, flagAvia, cityGuid
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesB2cpl: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providerCities/b2cpl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка городов boxberry
         * @summary Получение списка городов boxberry
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, cityGuid, region, district, cityGuid, courierZips
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesBoxberry: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providerCities/boxberry`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка городов cdek
         * @summary Получение списка городов cdek
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям fiasGuid, cityUuid, cdekId, cityName, oblName, countryCode, codCostLimit
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesCdek: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providerCities/cdek`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка городов dpd
         * @summary Получение списка городов dpd
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, dpdCityId, cityCode, cityGuid, cityName, countryCode, countryName, regionCode, regionName, abbreviation, isCodCost
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesDpd: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providerCities/dpd`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка типов доставки
         * @summary Получение списка типов доставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDeliveryTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/deliveryTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка способов оплаты
         * @summary Получение списка способов оплаты
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPaymentMethods: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/paymentMethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка типов приема
         * @summary Получение списка типов приема
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPickupTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/pickupTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка пунктов приема/выдачи
         * @summary Получение списка пунктов приема/выдачи
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям: id, providerKey, code, codeOriginal, name, postIndex, lat, lng, countryCode, region, regionType, city, cityGuid, cityType, community, communityGuid, communityType, area, street, streetType, house, block, office, address, url, email, phone, availableOperation, type, cod, paymentCash, paymentCard, multiplaceDeliveryAllowed, fittingRoom. Например: city&#x3D;Москва;providerKey&#x3D;cdek;availableOperation&#x3D;[2,3].  Документация работы фильтра: https://docs.apiship.ru/docs/api/query-filter/  Поиск по полям city/cityGuid или community/communityGuid ищет сразу и по city/cityGuid и по community/communityGuid
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {boolean} [stateCheckOff] Если stateCheckOff&#x3D;1 отдаются также ПВЗ у которых указан не точный адрес расположения
         * @param {boolean} [enabledCheckOff] Если enabledCheckOff&#x3D;1 Если enabledCheckOff&#x3D;1 и передан code в поле filter - отдаются также отключенные ПВЗ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPoints: async (limit?: number, offset?: number, filter?: string, fields?: string, stateCheckOff?: boolean, enabledCheckOff?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }

            if (stateCheckOff !== undefined) {
                localVarQueryParameter['stateCheckOff'] = stateCheckOff;
            }

            if (enabledCheckOff !== undefined) {
                localVarQueryParameter['enabledCheckOff'] = enabledCheckOff;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка соответствия статусов
         * @summary Список соответствия статусов СД со статусами сервиса
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [providerKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListProviderStatuses: async (limit?: number, offset?: number, providerKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providerStatuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (providerKey !== undefined) {
                localVarQueryParameter['providerKey'] = providerKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка поставщиков услуг
         * @summary Получение списка поставщиков услуг
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям key, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListProviders: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка дополнительных услуг
         * @summary Получение списка дополнительных услуг
         * @param {string} [providerKey] Фильтр услуг по провайдеру
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListServices: async (providerKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (providerKey !== undefined) {
                localVarQueryParameter['providerKey'] = providerKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка статусов
         * @summary Получение списка статусов
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям key, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListStatuses: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка актуальных тарифов
         * @summary Получение списка актуальных тарифов
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, providerKey, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListTariffs: async (limit?: number, offset?: number, filter?: string, fields?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/tariffs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение параметров подключения по ID
         * @summary Получение параметров подключения по ID
         * @param {number} id ID параметров подключения
         * @param {string} [_with] Список связанных данных, которые возвращаются в ответе. Возможные значения - company
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getOneParams: async (id: number, _with?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneParams', 'id', id)
            const localVarPath = `/lists/providers/connections/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (_with !== undefined) {
                localVarQueryParameter['with'] = _with;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка типов операций для точек приема/выдачи товаров
         * @summary Получение списка типов операций для точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOperationTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/operationTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение списка типов точек приема/выдачи товаров
         * @summary Получение списка типов точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/lists/pointTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение возможных параметров для подключения к службе доставки   [НОВЫЙ МЕТОД](#/connections/readSchemasConnection) 
         * @summary Получение возможных параметров для подключения к службе доставки
         * @param {string} providerKey Ключ провайдера (службы доставки)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getProvidersParams: async (providerKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerKey' is not null or undefined
            assertParamExists('getProvidersParams', 'providerKey', providerKey)
            const localVarPath = `/lists/providers/{providerKey}/params`
                .replace(`{${"providerKey"}}`, encodeURIComponent(String(providerKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListsApi - functional programming interface
 */
export const ListsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListsApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение всех параметров подключения к службам доставки
         * @summary Получение всех параметров подключения к службам доставки
         * @param {number} [limit] Лимит выборки
         * @param {number} [offset] Смещение выборки
         * @param {string} [_with] Список связанных данных, которые возвращаются в ответе. Возможные значения - company
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getAllParams(limit?: number, offset?: number, _with?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAllParams200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllParams(limit, offset, _with, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getAllParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка городов b2cpl
         * @summary Получение списка городов b2cpl
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, region, residence, zipFirst, zipLast, transportDays, flagCourier, flagPvz, flagAvia, cityGuid
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListCitiesB2cpl(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListCitiesB2cpl200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListCitiesB2cpl(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListCitiesB2cpl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка городов boxberry
         * @summary Получение списка городов boxberry
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, cityGuid, region, district, cityGuid, courierZips
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListCitiesBoxberry(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListCitiesBoxberry200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListCitiesBoxberry(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListCitiesBoxberry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка городов cdek
         * @summary Получение списка городов cdek
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям fiasGuid, cityUuid, cdekId, cityName, oblName, countryCode, codCostLimit
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListCitiesCdek(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListCitiesCdek200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListCitiesCdek(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListCitiesCdek']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка городов dpd
         * @summary Получение списка городов dpd
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, dpdCityId, cityCode, cityGuid, cityName, countryCode, countryName, regionCode, regionName, abbreviation, isCodCost
         * @param {string} [fields] Перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListCitiesDpd(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListCitiesDpd200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListCitiesDpd(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListCitiesDpd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка типов доставки
         * @summary Получение списка типов доставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListDeliveryTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListDeliveryTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListDeliveryTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка способов оплаты
         * @summary Получение списка способов оплаты
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListPaymentMethods(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentMethod>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListPaymentMethods(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListPaymentMethods']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка типов приема
         * @summary Получение списка типов приема
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListPickupTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PickupType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListPickupTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListPickupTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка пунктов приема/выдачи
         * @summary Получение списка пунктов приема/выдачи
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям: id, providerKey, code, codeOriginal, name, postIndex, lat, lng, countryCode, region, regionType, city, cityGuid, cityType, community, communityGuid, communityType, area, street, streetType, house, block, office, address, url, email, phone, availableOperation, type, cod, paymentCash, paymentCard, multiplaceDeliveryAllowed, fittingRoom. Например: city&#x3D;Москва;providerKey&#x3D;cdek;availableOperation&#x3D;[2,3].  Документация работы фильтра: https://docs.apiship.ru/docs/api/query-filter/  Поиск по полям city/cityGuid или community/communityGuid ищет сразу и по city/cityGuid и по community/communityGuid
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {boolean} [stateCheckOff] Если stateCheckOff&#x3D;1 отдаются также ПВЗ у которых указан не точный адрес расположения
         * @param {boolean} [enabledCheckOff] Если enabledCheckOff&#x3D;1 Если enabledCheckOff&#x3D;1 и передан code в поле filter - отдаются также отключенные ПВЗ
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListPoints(limit?: number, offset?: number, filter?: string, fields?: string, stateCheckOff?: boolean, enabledCheckOff?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListPoints200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListPoints(limit, offset, filter, fields, stateCheckOff, enabledCheckOff, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListPoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка соответствия статусов
         * @summary Список соответствия статусов СД со статусами сервиса
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [providerKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListProviderStatuses(limit?: number, offset?: number, providerKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListProviderStatuses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListProviderStatuses(limit, offset, providerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListProviderStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка поставщиков услуг
         * @summary Получение списка поставщиков услуг
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям key, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListProviders(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListProviders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListProviders(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка дополнительных услуг
         * @summary Получение списка дополнительных услуг
         * @param {string} [providerKey] Фильтр услуг по провайдеру
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListServices(providerKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdditionalServiceObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListServices(providerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListServices']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка статусов
         * @summary Получение списка статусов
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям key, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListStatuses(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListStatuses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListStatuses(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка актуальных тарифов
         * @summary Получение списка актуальных тарифов
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [filter] Возможна фильтрация по полям id, providerKey, name
         * @param {string} [fields] перечень отдаваемых полей, если не указан, отдаются все поля
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getListTariffs(limit?: number, offset?: number, filter?: string, fields?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetListTariffs200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getListTariffs(limit, offset, filter, fields, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getListTariffs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение параметров подключения по ID
         * @summary Получение параметров подключения по ID
         * @param {number} id ID параметров подключения
         * @param {string} [_with] Список связанных данных, которые возвращаются в ответе. Возможные значения - company
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getOneParams(id: number, _with?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Params>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneParams(id, _with, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getOneParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка типов операций для точек приема/выдачи товаров
         * @summary Получение списка типов операций для точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPointOperationTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PointOperation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPointOperationTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getPointOperationTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение списка типов точек приема/выдачи товаров
         * @summary Получение списка типов точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPointTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PointType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPointTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getPointTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение возможных параметров для подключения к службе доставки   [НОВЫЙ МЕТОД](#/connections/readSchemasConnection) 
         * @summary Получение возможных параметров для подключения к службе доставки
         * @param {string} providerKey Ключ провайдера (службы доставки)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getProvidersParams(providerKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvidersParams(providerKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ListsApi.getProvidersParams']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ListsApi - factory interface
 */
export const ListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListsApiFp(configuration)
    return {
        /**
         * Получение всех параметров подключения к службам доставки
         * @summary Получение всех параметров подключения к службам доставки
         * @param {ListsApiGetAllParamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getAllParams(requestParameters: ListsApiGetAllParamsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetAllParams200Response> {
            return localVarFp.getAllParams(requestParameters.limit, requestParameters.offset, requestParameters._with, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка городов b2cpl
         * @summary Получение списка городов b2cpl
         * @param {ListsApiGetListCitiesB2cplRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesB2cpl(requestParameters: ListsApiGetListCitiesB2cplRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListCitiesB2cpl200Response> {
            return localVarFp.getListCitiesB2cpl(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка городов boxberry
         * @summary Получение списка городов boxberry
         * @param {ListsApiGetListCitiesBoxberryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesBoxberry(requestParameters: ListsApiGetListCitiesBoxberryRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListCitiesBoxberry200Response> {
            return localVarFp.getListCitiesBoxberry(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка городов cdek
         * @summary Получение списка городов cdek
         * @param {ListsApiGetListCitiesCdekRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesCdek(requestParameters: ListsApiGetListCitiesCdekRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListCitiesCdek200Response> {
            return localVarFp.getListCitiesCdek(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка городов dpd
         * @summary Получение списка городов dpd
         * @param {ListsApiGetListCitiesDpdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListCitiesDpd(requestParameters: ListsApiGetListCitiesDpdRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListCitiesDpd200Response> {
            return localVarFp.getListCitiesDpd(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка типов доставки
         * @summary Получение списка типов доставки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListDeliveryTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<DeliveryType>> {
            return localVarFp.getListDeliveryTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка способов оплаты
         * @summary Получение списка способов оплаты
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPaymentMethods(options?: RawAxiosRequestConfig): AxiosPromise<Array<PaymentMethod>> {
            return localVarFp.getListPaymentMethods(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка типов приема
         * @summary Получение списка типов приема
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPickupTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<PickupType>> {
            return localVarFp.getListPickupTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка пунктов приема/выдачи
         * @summary Получение списка пунктов приема/выдачи
         * @param {ListsApiGetListPointsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListPoints(requestParameters: ListsApiGetListPointsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListPoints200Response> {
            return localVarFp.getListPoints(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, requestParameters.stateCheckOff, requestParameters.enabledCheckOff, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка соответствия статусов
         * @summary Список соответствия статусов СД со статусами сервиса
         * @param {ListsApiGetListProviderStatusesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListProviderStatuses(requestParameters: ListsApiGetListProviderStatusesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListProviderStatuses200Response> {
            return localVarFp.getListProviderStatuses(requestParameters.limit, requestParameters.offset, requestParameters.providerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка поставщиков услуг
         * @summary Получение списка поставщиков услуг
         * @param {ListsApiGetListProvidersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListProviders(requestParameters: ListsApiGetListProvidersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListProviders200Response> {
            return localVarFp.getListProviders(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка дополнительных услуг
         * @summary Получение списка дополнительных услуг
         * @param {ListsApiGetListServicesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListServices(requestParameters: ListsApiGetListServicesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<AdditionalServiceObject>> {
            return localVarFp.getListServices(requestParameters.providerKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка статусов
         * @summary Получение списка статусов
         * @param {ListsApiGetListStatusesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListStatuses(requestParameters: ListsApiGetListStatusesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListStatuses200Response> {
            return localVarFp.getListStatuses(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка актуальных тарифов
         * @summary Получение списка актуальных тарифов
         * @param {ListsApiGetListTariffsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListTariffs(requestParameters: ListsApiGetListTariffsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetListTariffs200Response> {
            return localVarFp.getListTariffs(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение параметров подключения по ID
         * @summary Получение параметров подключения по ID
         * @param {ListsApiGetOneParamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getOneParams(requestParameters: ListsApiGetOneParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Params> {
            return localVarFp.getOneParams(requestParameters.id, requestParameters._with, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка типов операций для точек приема/выдачи товаров
         * @summary Получение списка типов операций для точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointOperationTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<PointOperation>> {
            return localVarFp.getPointOperationTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение списка типов точек приема/выдачи товаров
         * @summary Получение списка типов точек приема/выдачи товаров
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPointTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<PointType>> {
            return localVarFp.getPointTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Получение возможных параметров для подключения к службе доставки   [НОВЫЙ МЕТОД](#/connections/readSchemasConnection) 
         * @summary Получение возможных параметров для подключения к службе доставки
         * @param {ListsApiGetProvidersParamsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getProvidersParams(requestParameters: ListsApiGetProvidersParamsRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getProvidersParams(requestParameters.providerKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAllParams operation in ListsApi.
 */
export interface ListsApiGetAllParamsRequest {
    /**
     * Лимит выборки
     */
    readonly limit?: number

    /**
     * Смещение выборки
     */
    readonly offset?: number

    /**
     * Список связанных данных, которые возвращаются в ответе. Возможные значения - company
     */
    readonly _with?: string
}

/**
 * Request parameters for getListCitiesB2cpl operation in ListsApi.
 */
export interface ListsApiGetListCitiesB2cplRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям id, region, residence, zipFirst, zipLast, transportDays, flagCourier, flagPvz, flagAvia, cityGuid
     */
    readonly filter?: string

    /**
     * Перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListCitiesBoxberry operation in ListsApi.
 */
export interface ListsApiGetListCitiesBoxberryRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям id, cityGuid, region, district, cityGuid, courierZips
     */
    readonly filter?: string

    /**
     * Перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListCitiesCdek operation in ListsApi.
 */
export interface ListsApiGetListCitiesCdekRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям fiasGuid, cityUuid, cdekId, cityName, oblName, countryCode, codCostLimit
     */
    readonly filter?: string

    /**
     * Перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListCitiesDpd operation in ListsApi.
 */
export interface ListsApiGetListCitiesDpdRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям id, dpdCityId, cityCode, cityGuid, cityName, countryCode, countryName, regionCode, regionName, abbreviation, isCodCost
     */
    readonly filter?: string

    /**
     * Перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListPoints operation in ListsApi.
 */
export interface ListsApiGetListPointsRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям: id, providerKey, code, codeOriginal, name, postIndex, lat, lng, countryCode, region, regionType, city, cityGuid, cityType, community, communityGuid, communityType, area, street, streetType, house, block, office, address, url, email, phone, availableOperation, type, cod, paymentCash, paymentCard, multiplaceDeliveryAllowed, fittingRoom. Например: city&#x3D;Москва;providerKey&#x3D;cdek;availableOperation&#x3D;[2,3].  Документация работы фильтра: https://docs.apiship.ru/docs/api/query-filter/  Поиск по полям city/cityGuid или community/communityGuid ищет сразу и по city/cityGuid и по community/communityGuid
     */
    readonly filter?: string

    /**
     * перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string

    /**
     * Если stateCheckOff&#x3D;1 отдаются также ПВЗ у которых указан не точный адрес расположения
     */
    readonly stateCheckOff?: boolean

    /**
     * Если enabledCheckOff&#x3D;1 Если enabledCheckOff&#x3D;1 и передан code в поле filter - отдаются также отключенные ПВЗ
     */
    readonly enabledCheckOff?: boolean
}

/**
 * Request parameters for getListProviderStatuses operation in ListsApi.
 */
export interface ListsApiGetListProviderStatusesRequest {
    readonly limit?: number

    readonly offset?: number

    readonly providerKey?: string
}

/**
 * Request parameters for getListProviders operation in ListsApi.
 */
export interface ListsApiGetListProvidersRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям key, name
     */
    readonly filter?: string

    /**
     * перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListServices operation in ListsApi.
 */
export interface ListsApiGetListServicesRequest {
    /**
     * Фильтр услуг по провайдеру
     */
    readonly providerKey?: string
}

/**
 * Request parameters for getListStatuses operation in ListsApi.
 */
export interface ListsApiGetListStatusesRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям key, name
     */
    readonly filter?: string

    /**
     * перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getListTariffs operation in ListsApi.
 */
export interface ListsApiGetListTariffsRequest {
    readonly limit?: number

    readonly offset?: number

    /**
     * Возможна фильтрация по полям id, providerKey, name
     */
    readonly filter?: string

    /**
     * перечень отдаваемых полей, если не указан, отдаются все поля
     */
    readonly fields?: string
}

/**
 * Request parameters for getOneParams operation in ListsApi.
 */
export interface ListsApiGetOneParamsRequest {
    /**
     * ID параметров подключения
     */
    readonly id: number

    /**
     * Список связанных данных, которые возвращаются в ответе. Возможные значения - company
     */
    readonly _with?: string
}

/**
 * Request parameters for getProvidersParams operation in ListsApi.
 */
export interface ListsApiGetProvidersParamsRequest {
    /**
     * Ключ провайдера (службы доставки)
     */
    readonly providerKey: string
}

/**
 * ListsApi - object-oriented interface
 */
export class ListsApi extends BaseAPI {
    /**
     * Получение всех параметров подключения к службам доставки
     * @summary Получение всех параметров подключения к службам доставки
     * @param {ListsApiGetAllParamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getAllParams(requestParameters: ListsApiGetAllParamsRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getAllParams(requestParameters.limit, requestParameters.offset, requestParameters._with, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка городов b2cpl
     * @summary Получение списка городов b2cpl
     * @param {ListsApiGetListCitiesB2cplRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListCitiesB2cpl(requestParameters: ListsApiGetListCitiesB2cplRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListCitiesB2cpl(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка городов boxberry
     * @summary Получение списка городов boxberry
     * @param {ListsApiGetListCitiesBoxberryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListCitiesBoxberry(requestParameters: ListsApiGetListCitiesBoxberryRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListCitiesBoxberry(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка городов cdek
     * @summary Получение списка городов cdek
     * @param {ListsApiGetListCitiesCdekRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListCitiesCdek(requestParameters: ListsApiGetListCitiesCdekRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListCitiesCdek(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка городов dpd
     * @summary Получение списка городов dpd
     * @param {ListsApiGetListCitiesDpdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListCitiesDpd(requestParameters: ListsApiGetListCitiesDpdRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListCitiesDpd(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка типов доставки
     * @summary Получение списка типов доставки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListDeliveryTypes(options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListDeliveryTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка способов оплаты
     * @summary Получение списка способов оплаты
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListPaymentMethods(options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListPaymentMethods(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка типов приема
     * @summary Получение списка типов приема
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListPickupTypes(options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListPickupTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка пунктов приема/выдачи
     * @summary Получение списка пунктов приема/выдачи
     * @param {ListsApiGetListPointsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListPoints(requestParameters: ListsApiGetListPointsRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListPoints(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, requestParameters.stateCheckOff, requestParameters.enabledCheckOff, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка соответствия статусов
     * @summary Список соответствия статусов СД со статусами сервиса
     * @param {ListsApiGetListProviderStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListProviderStatuses(requestParameters: ListsApiGetListProviderStatusesRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListProviderStatuses(requestParameters.limit, requestParameters.offset, requestParameters.providerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка поставщиков услуг
     * @summary Получение списка поставщиков услуг
     * @param {ListsApiGetListProvidersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListProviders(requestParameters: ListsApiGetListProvidersRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListProviders(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка дополнительных услуг
     * @summary Получение списка дополнительных услуг
     * @param {ListsApiGetListServicesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListServices(requestParameters: ListsApiGetListServicesRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListServices(requestParameters.providerKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка статусов
     * @summary Получение списка статусов
     * @param {ListsApiGetListStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListStatuses(requestParameters: ListsApiGetListStatusesRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListStatuses(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка актуальных тарифов
     * @summary Получение списка актуальных тарифов
     * @param {ListsApiGetListTariffsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getListTariffs(requestParameters: ListsApiGetListTariffsRequest = {}, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getListTariffs(requestParameters.limit, requestParameters.offset, requestParameters.filter, requestParameters.fields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение параметров подключения по ID
     * @summary Получение параметров подключения по ID
     * @param {ListsApiGetOneParamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getOneParams(requestParameters: ListsApiGetOneParamsRequest, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getOneParams(requestParameters.id, requestParameters._with, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка типов операций для точек приема/выдачи товаров
     * @summary Получение списка типов операций для точек приема/выдачи товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPointOperationTypes(options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getPointOperationTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение списка типов точек приема/выдачи товаров
     * @summary Получение списка типов точек приема/выдачи товаров
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPointTypes(options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getPointTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение возможных параметров для подключения к службе доставки   [НОВЫЙ МЕТОД](#/connections/readSchemasConnection) 
     * @summary Получение возможных параметров для подключения к службе доставки
     * @param {ListsApiGetProvidersParamsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    public getProvidersParams(requestParameters: ListsApiGetProvidersParamsRequest, options?: RawAxiosRequestConfig) {
        return ListsApiFp(this.configuration).getProvidersParams(requestParameters.providerKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LogsisApi - axios parameter creator
 */
export const LogsisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждение заказа
         * @summary Подтвердить заказ
         * @param {LogsisConfirmOrderRequest} [logsisConfirmOrderRequest] Объект типа ConfirmOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsisConfirmOrder: async (logsisConfirmOrderRequest?: LogsisConfirmOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logsis/confirmOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logsisConfirmOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление склада в системе Logsis
         * @summary Обновить склад
         * @param {LogsisUpdateWarehouseRequest} [logsisUpdateWarehouseRequest] Объект типа UpdateWarehouseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsisUpdateWarehouse: async (logsisUpdateWarehouseRequest?: LogsisUpdateWarehouseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logsis/updateWarehouse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logsisUpdateWarehouseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogsisApi - functional programming interface
 */
export const LogsisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogsisApiAxiosParamCreator(configuration)
    return {
        /**
         * Подтверждение заказа
         * @summary Подтвердить заказ
         * @param {LogsisConfirmOrderRequest} [logsisConfirmOrderRequest] Объект типа ConfirmOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsisConfirmOrder(logsisConfirmOrderRequest?: LogsisConfirmOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsisConfirmOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsisConfirmOrder(logsisConfirmOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsisApi.logsisConfirmOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление склада в системе Logsis
         * @summary Обновить склад
         * @param {LogsisUpdateWarehouseRequest} [logsisUpdateWarehouseRequest] Объект типа UpdateWarehouseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logsisUpdateWarehouse(logsisUpdateWarehouseRequest?: LogsisUpdateWarehouseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogsisUpdateWarehouseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logsisUpdateWarehouse(logsisUpdateWarehouseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LogsisApi.logsisUpdateWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LogsisApi - factory interface
 */
export const LogsisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogsisApiFp(configuration)
    return {
        /**
         * Подтверждение заказа
         * @summary Подтвердить заказ
         * @param {LogsisApiLogsisConfirmOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsisConfirmOrder(requestParameters: LogsisApiLogsisConfirmOrderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LogsisConfirmOrderResponse> {
            return localVarFp.logsisConfirmOrder(requestParameters.logsisConfirmOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление склада в системе Logsis
         * @summary Обновить склад
         * @param {LogsisApiLogsisUpdateWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logsisUpdateWarehouse(requestParameters: LogsisApiLogsisUpdateWarehouseRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<LogsisUpdateWarehouseResponse> {
            return localVarFp.logsisUpdateWarehouse(requestParameters.logsisUpdateWarehouseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for logsisConfirmOrder operation in LogsisApi.
 */
export interface LogsisApiLogsisConfirmOrderRequest {
    /**
     * Объект типа ConfirmOrderRequest
     */
    readonly logsisConfirmOrderRequest?: LogsisConfirmOrderRequest
}

/**
 * Request parameters for logsisUpdateWarehouse operation in LogsisApi.
 */
export interface LogsisApiLogsisUpdateWarehouseRequest {
    /**
     * Объект типа UpdateWarehouseRequest
     */
    readonly logsisUpdateWarehouseRequest?: LogsisUpdateWarehouseRequest
}

/**
 * LogsisApi - object-oriented interface
 */
export class LogsisApi extends BaseAPI {
    /**
     * Подтверждение заказа
     * @summary Подтвердить заказ
     * @param {LogsisApiLogsisConfirmOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logsisConfirmOrder(requestParameters: LogsisApiLogsisConfirmOrderRequest = {}, options?: RawAxiosRequestConfig) {
        return LogsisApiFp(this.configuration).logsisConfirmOrder(requestParameters.logsisConfirmOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление склада в системе Logsis
     * @summary Обновить склад
     * @param {LogsisApiLogsisUpdateWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logsisUpdateWarehouse(requestParameters: LogsisApiLogsisUpdateWarehouseRequest = {}, options?: RawAxiosRequestConfig) {
        return LogsisApiFp(this.configuration).logsisUpdateWarehouse(requestParameters.logsisUpdateWarehouseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderDocsApi - axios parameter creator
 */
export const OrderDocsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение ярлыков для заказов
         * @summary Получение ярлыков для заказов
         * @param {LabelsRequest} [labelsRequest] Объект типа LabelsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabels: async (labelsRequest?: LabelsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labelsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение актов приема-передачи заказов
         * @summary Получение актов приема-передачи заказов
         * @param {DocumentsRequest} [documentsRequest] Объект типа DocumentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWaybills: async (documentsRequest?: DocumentsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/waybills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderDocsApi - functional programming interface
 */
export const OrderDocsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderDocsApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение ярлыков для заказов
         * @summary Получение ярлыков для заказов
         * @param {LabelsRequest} [labelsRequest] Объект типа LabelsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabels(labelsRequest?: LabelsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLabels200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabels(labelsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderDocsApi.getLabels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение актов приема-передачи заказов
         * @summary Получение актов приема-передачи заказов
         * @param {DocumentsRequest} [documentsRequest] Объект типа DocumentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWaybills(documentsRequest?: DocumentsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWaybills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWaybills(documentsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderDocsApi.getWaybills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderDocsApi - factory interface
 */
export const OrderDocsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderDocsApiFp(configuration)
    return {
        /**
         * Получение ярлыков для заказов
         * @summary Получение ярлыков для заказов
         * @param {OrderDocsApiGetLabelsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabels(requestParameters: OrderDocsApiGetLabelsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetLabels200Response> {
            return localVarFp.getLabels(requestParameters.labelsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение актов приема-передачи заказов
         * @summary Получение актов приема-передачи заказов
         * @param {OrderDocsApiGetWaybillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWaybills(requestParameters: OrderDocsApiGetWaybillsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetWaybills200Response> {
            return localVarFp.getWaybills(requestParameters.documentsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getLabels operation in OrderDocsApi.
 */
export interface OrderDocsApiGetLabelsRequest {
    /**
     * Объект типа LabelsRequest
     */
    readonly labelsRequest?: LabelsRequest
}

/**
 * Request parameters for getWaybills operation in OrderDocsApi.
 */
export interface OrderDocsApiGetWaybillsRequest {
    /**
     * Объект типа DocumentsRequest
     */
    readonly documentsRequest?: DocumentsRequest
}

/**
 * OrderDocsApi - object-oriented interface
 */
export class OrderDocsApi extends BaseAPI {
    /**
     * Получение ярлыков для заказов
     * @summary Получение ярлыков для заказов
     * @param {OrderDocsApiGetLabelsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getLabels(requestParameters: OrderDocsApiGetLabelsRequest = {}, options?: RawAxiosRequestConfig) {
        return OrderDocsApiFp(this.configuration).getLabels(requestParameters.labelsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение актов приема-передачи заказов
     * @summary Получение актов приема-передачи заказов
     * @param {OrderDocsApiGetWaybillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWaybills(requestParameters: OrderDocsApiGetWaybillsRequest = {}, options?: RawAxiosRequestConfig) {
        return OrderDocsApiFp(this.configuration).getWaybills(requestParameters.documentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создание заказа в системе
         * @summary Создание заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder: async (platform?: string, orderRequest?: OrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (platform != null) {
                localVarHeaderParameter['Platform'] = String(platform);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Если по каким-то причинам товар не подошёл получателю, эта услуга легко позволит вернуть его отправителю. На данный момент поддерживается клиентский возврат для СДЕК, Почты России, E-Bulky и 5Post.
         * @summary Создание заказа на возврат (клиентский возврат)
         * @param {OrderReturnRequest} [orderReturnRequest] Объект типа OrderReturnRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReturnOrder: async (orderReturnRequest?: OrderReturnRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderReturnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Создание синхронного заказа в системе
         * @summary Создание синхронного заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSyncOrder: async (platform?: string, orderRequest?: OrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/sync`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (platform != null) {
                localVarHeaderParameter['Platform'] = String(platform);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Данный метод пытается удалить или отменить заказа из системы провайдера.
         * @summary Отмена заказа
         * @param {number} orderId ID заказа, который необходимо отменить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/cancel`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Помечает заказ удаленным. Данный метод не удаляет заказ из системы провайдера и не отменяет его. **В случае со СДЭК, заказ удаляется и из системы службы доставки.**
         * @summary Удаление заказа
         * @param {number} orderId ID заказа, который необходимо удалить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получает информацию по заказу
         * @summary Получение информации по заказу
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInfo: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderInfo', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получения кода подтверждения
         * @summary Получение кода подтверждения
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdCodeGet: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdCodeGet', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/code`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение информации о курьере, назначенном на заказ
         * @summary Получение информации о курьере
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdCourierGet: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('ordersOrderIdCourierGet', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/courier`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Повторно отправляет заказ в СД
         * @summary Повторная отправка заказа в СД
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resend: async (orderId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('resend', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/resend`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Изменение заказа в системе
         * @summary Изменение заказа
         * @param {number} orderId ID заказа, который необходимо изменить
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (orderId: number, platform?: string, orderRequest?: OrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrder', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (platform != null) {
                localVarHeaderParameter['Platform'] = String(platform);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление доступно, если у заказа указано только 1 место, либо товары переданы в items заказа
         * @summary Обновление товаров заказа
         * @param {number} orderId ID заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {UpdateOrderItemsRequest} [updateOrderItemsRequest] Объект типа UpdateOrderItemsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderItems: async (orderId: number, platform?: string, updateOrderItemsRequest?: UpdateOrderItemsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('updateOrderItems', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/items`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (platform != null) {
                localVarHeaderParameter['Platform'] = String(platform);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateOrderItemsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Загрузка xlsx файла c данными о заказах
         * @summary Загрузка xlsx файла c данными о заказах
         * @param {OrdersUploadRequest} [ordersUploadRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOrders: async (ordersUploadRequest?: OrdersUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ordersUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Валидация заказа в системе без отправки в Службу Доставки
         * @summary Валидация заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOrder: async (platform?: string, orderRequest?: OrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (platform != null) {
                localVarHeaderParameter['Platform'] = String(platform);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Создание заказа в системе
         * @summary Создание заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrder(platform?: string, orderRequest?: OrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrder(platform, orderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.addOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Если по каким-то причинам товар не подошёл получателю, эта услуга легко позволит вернуть его отправителю. На данный момент поддерживается клиентский возврат для СДЕК, Почты России, E-Bulky и 5Post.
         * @summary Создание заказа на возврат (клиентский возврат)
         * @param {OrderReturnRequest} [orderReturnRequest] Объект типа OrderReturnRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addReturnOrder(orderReturnRequest?: OrderReturnRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderSyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addReturnOrder(orderReturnRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.addReturnOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Создание синхронного заказа в системе
         * @summary Создание синхронного заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSyncOrder(platform?: string, orderRequest?: OrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderSyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSyncOrder(platform, orderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.addSyncOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Данный метод пытается удалить или отменить заказа из системы провайдера.
         * @summary Отмена заказа
         * @param {number} orderId ID заказа, который необходимо отменить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.cancelOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Помечает заказ удаленным. Данный метод не удаляет заказ из системы провайдера и не отменяет его. **В случае со СДЭК, заказ удаляется и из системы службы доставки.**
         * @summary Удаление заказа
         * @param {number} orderId ID заказа, который необходимо удалить
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.deleteOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получает информацию по заказу
         * @summary Получение информации по заказу
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderInfo(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderInfo(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.getOrderInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получения кода подтверждения
         * @summary Получение кода подтверждения
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdCodeGet(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlacementCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdCodeGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersOrderIdCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение информации о курьере, назначенном на заказ
         * @summary Получение информации о курьере
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ordersOrderIdCourierGet(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderCourierResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ordersOrderIdCourierGet(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.ordersOrderIdCourierGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Повторно отправляет заказ в СД
         * @summary Повторная отправка заказа в СД
         * @param {number} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resend(orderId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resend(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.resend']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Изменение заказа в системе
         * @summary Изменение заказа
         * @param {number} orderId ID заказа, который необходимо изменить
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(orderId: number, platform?: string, orderRequest?: OrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(orderId, platform, orderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.updateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Обновление доступно, если у заказа указано только 1 место, либо товары переданы в items заказа
         * @summary Обновление товаров заказа
         * @param {number} orderId ID заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {UpdateOrderItemsRequest} [updateOrderItemsRequest] Объект типа UpdateOrderItemsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrderItems(orderId: number, platform?: string, updateOrderItemsRequest?: UpdateOrderItemsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrderItems(orderId, platform, updateOrderItemsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.updateOrderItems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Загрузка xlsx файла c данными о заказах
         * @summary Загрузка xlsx файла c данными о заказах
         * @param {OrdersUploadRequest} [ordersUploadRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadOrders(ordersUploadRequest?: OrdersUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadOrders(ordersUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.uploadOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Валидация заказа в системе без отправки в Службу Доставки
         * @summary Валидация заказа
         * @param {string} [platform] ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
         * @param {OrderRequest} [orderRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateOrder(platform?: string, orderRequest?: OrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateOrder(platform, orderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrdersApi.validateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Создание заказа в системе
         * @summary Создание заказа
         * @param {OrdersApiAddOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder(requestParameters: OrdersApiAddOrderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.addOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Если по каким-то причинам товар не подошёл получателю, эта услуга легко позволит вернуть его отправителю. На данный момент поддерживается клиентский возврат для СДЕК, Почты России, E-Bulky и 5Post.
         * @summary Создание заказа на возврат (клиентский возврат)
         * @param {OrdersApiAddReturnOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addReturnOrder(requestParameters: OrdersApiAddReturnOrderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<OrderSyncResponse> {
            return localVarFp.addReturnOrder(requestParameters.orderReturnRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Создание синхронного заказа в системе
         * @summary Создание синхронного заказа
         * @param {OrdersApiAddSyncOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSyncOrder(requestParameters: OrdersApiAddSyncOrderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<OrderSyncResponse> {
            return localVarFp.addSyncOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Данный метод пытается удалить или отменить заказа из системы провайдера.
         * @summary Отмена заказа
         * @param {OrdersApiCancelOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(requestParameters: OrdersApiCancelOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelOrderResponse> {
            return localVarFp.cancelOrder(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Помечает заказ удаленным. Данный метод не удаляет заказ из системы провайдера и не отменяет его. **В случае со СДЭК, заказ удаляется и из системы службы доставки.**
         * @summary Удаление заказа
         * @param {OrdersApiDeleteOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(requestParameters: OrdersApiDeleteOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteOrderResponse> {
            return localVarFp.deleteOrder(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получает информацию по заказу
         * @summary Получение информации по заказу
         * @param {OrdersApiGetOrderInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInfo(requestParameters: OrdersApiGetOrderInfoRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderInfoResponse> {
            return localVarFp.getOrderInfo(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получения кода подтверждения
         * @summary Получение кода подтверждения
         * @param {OrdersApiOrdersOrderIdCodeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdCodeGet(requestParameters: OrdersApiOrdersOrderIdCodeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlacementCodeResponse> {
            return localVarFp.ordersOrderIdCodeGet(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение информации о курьере, назначенном на заказ
         * @summary Получение информации о курьере
         * @param {OrdersApiOrdersOrderIdCourierGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersOrderIdCourierGet(requestParameters: OrdersApiOrdersOrderIdCourierGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderCourierResponse> {
            return localVarFp.ordersOrderIdCourierGet(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Повторно отправляет заказ в СД
         * @summary Повторная отправка заказа в СД
         * @param {OrdersApiResendRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resend(requestParameters: OrdersApiResendRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.resend(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Изменение заказа в системе
         * @summary Изменение заказа
         * @param {OrdersApiUpdateOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(requestParameters: OrdersApiUpdateOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOrder(requestParameters.orderId, requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление доступно, если у заказа указано только 1 место, либо товары переданы в items заказа
         * @summary Обновление товаров заказа
         * @param {OrdersApiUpdateOrderItemsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderItems(requestParameters: OrdersApiUpdateOrderItemsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.updateOrderItems(requestParameters.orderId, requestParameters.platform, requestParameters.updateOrderItemsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Загрузка xlsx файла c данными о заказах
         * @summary Загрузка xlsx файла c данными о заказах
         * @param {OrdersApiUploadOrdersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOrders(requestParameters: OrdersApiUploadOrdersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<OrderUploadResponse> {
            return localVarFp.uploadOrders(requestParameters.ordersUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Валидация заказа в системе без отправки в Службу Доставки
         * @summary Валидация заказа
         * @param {OrdersApiValidateOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateOrder(requestParameters: OrdersApiValidateOrderRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ValidateOrderResponse> {
            return localVarFp.validateOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addOrder operation in OrdersApi.
 */
export interface OrdersApiAddOrderRequest {
    /**
     * ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
     */
    readonly platform?: string

    /**
     * Объект типа OrderRequest
     */
    readonly orderRequest?: OrderRequest
}

/**
 * Request parameters for addReturnOrder operation in OrdersApi.
 */
export interface OrdersApiAddReturnOrderRequest {
    /**
     * Объект типа OrderReturnRequest
     */
    readonly orderReturnRequest?: OrderReturnRequest
}

/**
 * Request parameters for addSyncOrder operation in OrdersApi.
 */
export interface OrdersApiAddSyncOrderRequest {
    /**
     * ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
     */
    readonly platform?: string

    /**
     * Объект типа OrderRequest
     */
    readonly orderRequest?: OrderRequest
}

/**
 * Request parameters for cancelOrder operation in OrdersApi.
 */
export interface OrdersApiCancelOrderRequest {
    /**
     * ID заказа, который необходимо отменить
     */
    readonly orderId: number
}

/**
 * Request parameters for deleteOrder operation in OrdersApi.
 */
export interface OrdersApiDeleteOrderRequest {
    /**
     * ID заказа, который необходимо удалить
     */
    readonly orderId: number
}

/**
 * Request parameters for getOrderInfo operation in OrdersApi.
 */
export interface OrdersApiGetOrderInfoRequest {
    /**
     * ID заказа
     */
    readonly orderId: number
}

/**
 * Request parameters for ordersOrderIdCodeGet operation in OrdersApi.
 */
export interface OrdersApiOrdersOrderIdCodeGetRequest {
    /**
     * ID заказа
     */
    readonly orderId: number
}

/**
 * Request parameters for ordersOrderIdCourierGet operation in OrdersApi.
 */
export interface OrdersApiOrdersOrderIdCourierGetRequest {
    /**
     * ID заказа
     */
    readonly orderId: number
}

/**
 * Request parameters for resend operation in OrdersApi.
 */
export interface OrdersApiResendRequest {
    /**
     * ID заказа
     */
    readonly orderId: number
}

/**
 * Request parameters for updateOrder operation in OrdersApi.
 */
export interface OrdersApiUpdateOrderRequest {
    /**
     * ID заказа, который необходимо изменить
     */
    readonly orderId: number

    /**
     * ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
     */
    readonly platform?: string

    /**
     * Объект типа OrderRequest
     */
    readonly orderRequest?: OrderRequest
}

/**
 * Request parameters for updateOrderItems operation in OrdersApi.
 */
export interface OrdersApiUpdateOrderItemsRequest {
    /**
     * ID заказа
     */
    readonly orderId: number

    /**
     * ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
     */
    readonly platform?: string

    /**
     * Объект типа UpdateOrderItemsRequest
     */
    readonly updateOrderItemsRequest?: UpdateOrderItemsRequest
}

/**
 * Request parameters for uploadOrders operation in OrdersApi.
 */
export interface OrdersApiUploadOrdersRequest {
    /**
     * Объект типа OrderRequest
     */
    readonly ordersUploadRequest?: OrdersUploadRequest
}

/**
 * Request parameters for validateOrder operation in OrdersApi.
 */
export interface OrdersApiValidateOrderRequest {
    /**
     * ТОЛЬКО ДЛЯ РАЗРАБОТЧИКОВ МОДУЛЕЙ! Код модуля (согласовывается со службой поддержки). Если заказ переедается из модуля, то поле обязательно!
     */
    readonly platform?: string

    /**
     * Объект типа OrderRequest
     */
    readonly orderRequest?: OrderRequest
}

/**
 * OrdersApi - object-oriented interface
 */
export class OrdersApi extends BaseAPI {
    /**
     * Создание заказа в системе
     * @summary Создание заказа
     * @param {OrdersApiAddOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addOrder(requestParameters: OrdersApiAddOrderRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).addOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Если по каким-то причинам товар не подошёл получателю, эта услуга легко позволит вернуть его отправителю. На данный момент поддерживается клиентский возврат для СДЕК, Почты России, E-Bulky и 5Post.
     * @summary Создание заказа на возврат (клиентский возврат)
     * @param {OrdersApiAddReturnOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addReturnOrder(requestParameters: OrdersApiAddReturnOrderRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).addReturnOrder(requestParameters.orderReturnRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Создание синхронного заказа в системе
     * @summary Создание синхронного заказа
     * @param {OrdersApiAddSyncOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public addSyncOrder(requestParameters: OrdersApiAddSyncOrderRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).addSyncOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Данный метод пытается удалить или отменить заказа из системы провайдера.
     * @summary Отмена заказа
     * @param {OrdersApiCancelOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public cancelOrder(requestParameters: OrdersApiCancelOrderRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancelOrder(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Помечает заказ удаленным. Данный метод не удаляет заказ из системы провайдера и не отменяет его. **В случае со СДЭК, заказ удаляется и из системы службы доставки.**
     * @summary Удаление заказа
     * @param {OrdersApiDeleteOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteOrder(requestParameters: OrdersApiDeleteOrderRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).deleteOrder(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получает информацию по заказу
     * @summary Получение информации по заказу
     * @param {OrdersApiGetOrderInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderInfo(requestParameters: OrdersApiGetOrderInfoRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrderInfo(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получения кода подтверждения
     * @summary Получение кода подтверждения
     * @param {OrdersApiOrdersOrderIdCodeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdCodeGet(requestParameters: OrdersApiOrdersOrderIdCodeGetRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersOrderIdCodeGet(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение информации о курьере, назначенном на заказ
     * @summary Получение информации о курьере
     * @param {OrdersApiOrdersOrderIdCourierGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ordersOrderIdCourierGet(requestParameters: OrdersApiOrdersOrderIdCourierGetRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).ordersOrderIdCourierGet(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Повторно отправляет заказ в СД
     * @summary Повторная отправка заказа в СД
     * @param {OrdersApiResendRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resend(requestParameters: OrdersApiResendRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).resend(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Изменение заказа в системе
     * @summary Изменение заказа
     * @param {OrdersApiUpdateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOrder(requestParameters: OrdersApiUpdateOrderRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updateOrder(requestParameters.orderId, requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление доступно, если у заказа указано только 1 место, либо товары переданы в items заказа
     * @summary Обновление товаров заказа
     * @param {OrdersApiUpdateOrderItemsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateOrderItems(requestParameters: OrdersApiUpdateOrderItemsRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).updateOrderItems(requestParameters.orderId, requestParameters.platform, requestParameters.updateOrderItemsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Загрузка xlsx файла c данными о заказах
     * @summary Загрузка xlsx файла c данными о заказах
     * @param {OrdersApiUploadOrdersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadOrders(requestParameters: OrdersApiUploadOrdersRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).uploadOrders(requestParameters.ordersUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Валидация заказа в системе без отправки в Службу Доставки
     * @summary Валидация заказа
     * @param {OrdersApiValidateOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public validateOrder(requestParameters: OrdersApiValidateOrderRequest = {}, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).validateOrder(requestParameters.platform, requestParameters.orderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusesApi - axios parameter creator
 */
export const StatusesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Получение статуса заказа
         * @summary Получение статуса заказа
         * @param {GetOrderStatusOrderIdParameter} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatus: async (orderId: GetOrderStatusOrderIdParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderStatus', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение статуса заказа по номеру заказа в системе клиента
         * @summary Получение статуса заказа по номеру заказа в системе клиента
         * @param {string} clientNumber ID заказа в системе клиента
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusByClientNumber: async (clientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientNumber' is not null or undefined
            assertParamExists('getOrderStatusByClientNumber', 'clientNumber', clientNumber)
            const localVarPath = `/orders/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (clientNumber !== undefined) {
                localVarQueryParameter['clientNumber'] = clientNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение истории статусов заказа
         * @summary Получение истории статусов заказа
         * @param {GetOrderStatusOrderIdParameter} orderId ID заказа
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusHistory: async (orderId: GetOrderStatusOrderIdParameter, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderStatusHistory', 'orderId', orderId)
            const localVarPath = `/orders/{orderId}/statusHistory`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение истории статуса заказа по номеру заказа в системе клиента
         * @summary Получение истории статуса заказа по номеру заказа в системе клиента
         * @param {string} clientNumber ID заказа в системе клиента
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusHistoryByClientNumber: async (clientNumber: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientNumber' is not null or undefined
            assertParamExists('getOrderStatusHistoryByClientNumber', 'clientNumber', clientNumber)
            const localVarPath = `/orders/status/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (clientNumber !== undefined) {
                localVarQueryParameter['clientNumber'] = clientNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение статусов по нескольким заказам
         * @summary Получение статусов по нескольким заказам
         * @param {StatusIdsRequest} [statusIdsRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatuses: async (statusIdsRequest?: StatusIdsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statusIdsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение истории изменения всех статусов с определенной даты
         * @summary Получение истории изменения всех статусов с определенной даты
         * @param {string} date Дата заказов (в формате 2015-07-30T13:14:37+03:00), с которой необходимо получить историю статусов
         * @param {number} [offset] Minimum - 0
         * @param {number} [limit] Minimum - 1, Maximum - 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusHistoryByDate: async (date: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getStatusHistoryByDate', 'date', date)
            const localVarPath = `/orders/statuses/history/date/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение истории изменения всех статусов по заданному интервалу
         * @summary Получение истории изменения всех статусов по заданному интервалу
         * @param {string} from Дата начала периода (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;)
         * @param {string} to Дата окончания периода (в формате \&#39;2015-08-010T13:14:37+03:00\&#39;)
         * @param {string} [filter] Возможна фильтрация по providerKey. Например providerKey&#x3D;cdek или providerKey&#x3D;[cdek,dpd]
         * @param {number} [offset] Minimum - 0
         * @param {number} [limit] Minimum - 1, Maximum - 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusHistoryByInterval: async (from: string, to: string, filter?: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getStatusHistoryByInterval', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getStatusHistoryByInterval', 'to', to)
            const localVarPath = `/orders/statuses/interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @summary Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @param {string} date Дата (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;), после которой запрашиваются статусы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusesByDateNew: async (date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('getStatusesByDateNew', 'date', date)
            const localVarPath = `/orders/statuses/date/{date}`
                .replace(`{${"date"}}`, encodeURIComponent(String(date)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusesApi - functional programming interface
 */
export const StatusesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusesApiAxiosParamCreator(configuration)
    return {
        /**
         * Получение статуса заказа
         * @summary Получение статуса заказа
         * @param {GetOrderStatusOrderIdParameter} orderId ID заказа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatus(orderId: GetOrderStatusOrderIdParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatus(orderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getOrderStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение статуса заказа по номеру заказа в системе клиента
         * @summary Получение статуса заказа по номеру заказа в системе клиента
         * @param {string} clientNumber ID заказа в системе клиента
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatusByClientNumber(clientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatusByClientNumber(clientNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getOrderStatusByClientNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение истории статусов заказа
         * @summary Получение истории статусов заказа
         * @param {GetOrderStatusOrderIdParameter} orderId ID заказа
         * @param {number} [offset] Minimum - 0, Maximum - 5000
         * @param {number} [limit] Minimum - 1, Maximum - 100
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatusHistory(orderId: GetOrderStatusOrderIdParameter, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderStatusHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatusHistory(orderId, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getOrderStatusHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение истории статуса заказа по номеру заказа в системе клиента
         * @summary Получение истории статуса заказа по номеру заказа в системе клиента
         * @param {string} clientNumber ID заказа в системе клиента
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatusHistoryByClientNumber(clientNumber: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderStatusHistoryByClientNumber200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatusHistoryByClientNumber(clientNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getOrderStatusHistoryByClientNumber']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение статусов по нескольким заказам
         * @summary Получение статусов по нескольким заказам
         * @param {StatusIdsRequest} [statusIdsRequest] Объект типа OrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderStatuses(statusIdsRequest?: StatusIdsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderStatuses200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderStatuses(statusIdsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getOrderStatuses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение истории изменения всех статусов с определенной даты
         * @summary Получение истории изменения всех статусов с определенной даты
         * @param {string} date Дата заказов (в формате 2015-07-30T13:14:37+03:00), с которой необходимо получить историю статусов
         * @param {number} [offset] Minimum - 0
         * @param {number} [limit] Minimum - 1, Maximum - 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusHistoryByDate(date: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusHistoryByDate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusHistoryByDate(date, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getStatusHistoryByDate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение истории изменения всех статусов по заданному интервалу
         * @summary Получение истории изменения всех статусов по заданному интервалу
         * @param {string} from Дата начала периода (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;)
         * @param {string} to Дата окончания периода (в формате \&#39;2015-08-010T13:14:37+03:00\&#39;)
         * @param {string} [filter] Возможна фильтрация по providerKey. Например providerKey&#x3D;cdek или providerKey&#x3D;[cdek,dpd]
         * @param {number} [offset] Minimum - 0
         * @param {number} [limit] Minimum - 1, Maximum - 1000
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusHistoryByInterval(from: string, to: string, filter?: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatusHistoryByInterval200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusHistoryByInterval(from, to, filter, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getStatusHistoryByInterval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @summary Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @param {string} date Дата (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;), после которой запрашиваются статусы
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusesByDateNew(date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StatusCommon>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusesByDateNew(date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusesApi.getStatusesByDateNew']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusesApi - factory interface
 */
export const StatusesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusesApiFp(configuration)
    return {
        /**
         * Получение статуса заказа
         * @summary Получение статуса заказа
         * @param {StatusesApiGetOrderStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatus(requestParameters: StatusesApiGetOrderStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderStatus200Response> {
            return localVarFp.getOrderStatus(requestParameters.orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение статуса заказа по номеру заказа в системе клиента
         * @summary Получение статуса заказа по номеру заказа в системе клиента
         * @param {StatusesApiGetOrderStatusByClientNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusByClientNumber(requestParameters: StatusesApiGetOrderStatusByClientNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderStatus200Response> {
            return localVarFp.getOrderStatusByClientNumber(requestParameters.clientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение истории статусов заказа
         * @summary Получение истории статусов заказа
         * @param {StatusesApiGetOrderStatusHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusHistory(requestParameters: StatusesApiGetOrderStatusHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderStatusHistory200Response> {
            return localVarFp.getOrderStatusHistory(requestParameters.orderId, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение истории статуса заказа по номеру заказа в системе клиента
         * @summary Получение истории статуса заказа по номеру заказа в системе клиента
         * @param {StatusesApiGetOrderStatusHistoryByClientNumberRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatusHistoryByClientNumber(requestParameters: StatusesApiGetOrderStatusHistoryByClientNumberRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderStatusHistoryByClientNumber200Response> {
            return localVarFp.getOrderStatusHistoryByClientNumber(requestParameters.clientNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение статусов по нескольким заказам
         * @summary Получение статусов по нескольким заказам
         * @param {StatusesApiGetOrderStatusesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderStatuses(requestParameters: StatusesApiGetOrderStatusesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetOrderStatuses200Response> {
            return localVarFp.getOrderStatuses(requestParameters.statusIdsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение истории изменения всех статусов с определенной даты
         * @summary Получение истории изменения всех статусов с определенной даты
         * @param {StatusesApiGetStatusHistoryByDateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusHistoryByDate(requestParameters: StatusesApiGetStatusHistoryByDateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetStatusHistoryByDate200Response> {
            return localVarFp.getStatusHistoryByDate(requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение истории изменения всех статусов по заданному интервалу
         * @summary Получение истории изменения всех статусов по заданному интервалу
         * @param {StatusesApiGetStatusHistoryByIntervalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusHistoryByInterval(requestParameters: StatusesApiGetStatusHistoryByIntervalRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetStatusHistoryByInterval200Response> {
            return localVarFp.getStatusHistoryByInterval(requestParameters.from, requestParameters.to, requestParameters.filter, requestParameters.offset, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @summary Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
         * @param {StatusesApiGetStatusesByDateNewRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusesByDateNew(requestParameters: StatusesApiGetStatusesByDateNewRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<StatusCommon>> {
            return localVarFp.getStatusesByDateNew(requestParameters.date, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getOrderStatus operation in StatusesApi.
 */
export interface StatusesApiGetOrderStatusRequest {
    /**
     * ID заказа
     */
    readonly orderId: GetOrderStatusOrderIdParameter
}

/**
 * Request parameters for getOrderStatusByClientNumber operation in StatusesApi.
 */
export interface StatusesApiGetOrderStatusByClientNumberRequest {
    /**
     * ID заказа в системе клиента
     */
    readonly clientNumber: string
}

/**
 * Request parameters for getOrderStatusHistory operation in StatusesApi.
 */
export interface StatusesApiGetOrderStatusHistoryRequest {
    /**
     * ID заказа
     */
    readonly orderId: GetOrderStatusOrderIdParameter

    /**
     * Minimum - 0, Maximum - 5000
     */
    readonly offset?: number

    /**
     * Minimum - 1, Maximum - 100
     */
    readonly limit?: number
}

/**
 * Request parameters for getOrderStatusHistoryByClientNumber operation in StatusesApi.
 */
export interface StatusesApiGetOrderStatusHistoryByClientNumberRequest {
    /**
     * ID заказа в системе клиента
     */
    readonly clientNumber: string
}

/**
 * Request parameters for getOrderStatuses operation in StatusesApi.
 */
export interface StatusesApiGetOrderStatusesRequest {
    /**
     * Объект типа OrderRequest
     */
    readonly statusIdsRequest?: StatusIdsRequest
}

/**
 * Request parameters for getStatusHistoryByDate operation in StatusesApi.
 */
export interface StatusesApiGetStatusHistoryByDateRequest {
    /**
     * Дата заказов (в формате 2015-07-30T13:14:37+03:00), с которой необходимо получить историю статусов
     */
    readonly date: string

    /**
     * Minimum - 0
     */
    readonly offset?: number

    /**
     * Minimum - 1, Maximum - 1000
     */
    readonly limit?: number
}

/**
 * Request parameters for getStatusHistoryByInterval operation in StatusesApi.
 */
export interface StatusesApiGetStatusHistoryByIntervalRequest {
    /**
     * Дата начала периода (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;)
     */
    readonly from: string

    /**
     * Дата окончания периода (в формате \&#39;2015-08-010T13:14:37+03:00\&#39;)
     */
    readonly to: string

    /**
     * Возможна фильтрация по providerKey. Например providerKey&#x3D;cdek или providerKey&#x3D;[cdek,dpd]
     */
    readonly filter?: string

    /**
     * Minimum - 0
     */
    readonly offset?: number

    /**
     * Minimum - 1, Maximum - 1000
     */
    readonly limit?: number
}

/**
 * Request parameters for getStatusesByDateNew operation in StatusesApi.
 */
export interface StatusesApiGetStatusesByDateNewRequest {
    /**
     * Дата (в формате \&#39;2015-07-30T13:14:37+03:00\&#39;), после которой запрашиваются статусы
     */
    readonly date: string
}

/**
 * StatusesApi - object-oriented interface
 */
export class StatusesApi extends BaseAPI {
    /**
     * Получение статуса заказа
     * @summary Получение статуса заказа
     * @param {StatusesApiGetOrderStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderStatus(requestParameters: StatusesApiGetOrderStatusRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getOrderStatus(requestParameters.orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение статуса заказа по номеру заказа в системе клиента
     * @summary Получение статуса заказа по номеру заказа в системе клиента
     * @param {StatusesApiGetOrderStatusByClientNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderStatusByClientNumber(requestParameters: StatusesApiGetOrderStatusByClientNumberRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getOrderStatusByClientNumber(requestParameters.clientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение истории статусов заказа
     * @summary Получение истории статусов заказа
     * @param {StatusesApiGetOrderStatusHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderStatusHistory(requestParameters: StatusesApiGetOrderStatusHistoryRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getOrderStatusHistory(requestParameters.orderId, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение истории статуса заказа по номеру заказа в системе клиента
     * @summary Получение истории статуса заказа по номеру заказа в системе клиента
     * @param {StatusesApiGetOrderStatusHistoryByClientNumberRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderStatusHistoryByClientNumber(requestParameters: StatusesApiGetOrderStatusHistoryByClientNumberRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getOrderStatusHistoryByClientNumber(requestParameters.clientNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение статусов по нескольким заказам
     * @summary Получение статусов по нескольким заказам
     * @param {StatusesApiGetOrderStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getOrderStatuses(requestParameters: StatusesApiGetOrderStatusesRequest = {}, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getOrderStatuses(requestParameters.statusIdsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение истории изменения всех статусов с определенной даты
     * @summary Получение истории изменения всех статусов с определенной даты
     * @param {StatusesApiGetStatusHistoryByDateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusHistoryByDate(requestParameters: StatusesApiGetStatusHistoryByDateRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getStatusHistoryByDate(requestParameters.date, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение истории изменения всех статусов по заданному интервалу
     * @summary Получение истории изменения всех статусов по заданному интервалу
     * @param {StatusesApiGetStatusHistoryByIntervalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusHistoryByInterval(requestParameters: StatusesApiGetStatusHistoryByIntervalRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getStatusHistoryByInterval(requestParameters.from, requestParameters.to, requestParameters.filter, requestParameters.offset, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
     * @summary Получение измененных статусов по всем заказам клиента (company) после указанной в методе даты
     * @param {StatusesApiGetStatusesByDateNewRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getStatusesByDateNew(requestParameters: StatusesApiGetStatusesByDateNewRequest, options?: RawAxiosRequestConfig) {
        return StatusesApiFp(this.configuration).getStatusesByDateNew(requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Автоматически регистрирует пользователя в системе без подтверждения регистрации через email. Для работы метода необходимо получить специальные права доступа в службе поддержки.
         * @summary Авторегистрация пользователя
         * @param {SignupUserRequest} [signupUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoSignupUser: async (signupUserRequest?: SignupUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/autosignup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Авторизует пользователя и выдает ему токен для доступа к API
         * @summary Авторизация пользователя. Получение токена к API
         * @param {LoginRequest} loginRequest Объект типа LoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('loginUser', 'loginRequest', loginRequest)
            const localVarPath = `/users/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Регистрирует пользователя в системе. Для завершения регистрации на email придет письмо с подтверждением.
         * @summary Регистрация пользователя
         * @param {SignupUserRequest} [signupUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser: async (signupUserRequest?: SignupUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Автоматически регистрирует пользователя в системе без подтверждения регистрации через email. Для работы метода необходимо получить специальные права доступа в службе поддержки.
         * @summary Авторегистрация пользователя
         * @param {SignupUserRequest} [signupUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoSignupUser(signupUserRequest?: SignupUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoSignupUser(signupUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.autoSignupUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Авторизует пользователя и выдает ему токен для доступа к API
         * @summary Авторизация пользователя. Получение токена к API
         * @param {LoginRequest} loginRequest Объект типа LoginRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.loginUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Регистрирует пользователя в системе. Для завершения регистрации на email придет письмо с подтверждением.
         * @summary Регистрация пользователя
         * @param {SignupUserRequest} [signupUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signupUser(signupUserRequest?: SignupUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signupUser(signupUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.signupUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Автоматически регистрирует пользователя в системе без подтверждения регистрации через email. Для работы метода необходимо получить специальные права доступа в службе поддержки.
         * @summary Авторегистрация пользователя
         * @param {UsersApiAutoSignupUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoSignupUser(requestParameters: UsersApiAutoSignupUserRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.autoSignupUser(requestParameters.signupUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Авторизует пользователя и выдает ему токен для доступа к API
         * @summary Авторизация пользователя. Получение токена к API
         * @param {UsersApiLoginUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(requestParameters: UsersApiLoginUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.loginUser(requestParameters.loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Регистрирует пользователя в системе. Для завершения регистрации на email придет письмо с подтверждением.
         * @summary Регистрация пользователя
         * @param {UsersApiSignupUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signupUser(requestParameters: UsersApiSignupUserRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.signupUser(requestParameters.signupUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for autoSignupUser operation in UsersApi.
 */
export interface UsersApiAutoSignupUserRequest {
    readonly signupUserRequest?: SignupUserRequest
}

/**
 * Request parameters for loginUser operation in UsersApi.
 */
export interface UsersApiLoginUserRequest {
    /**
     * Объект типа LoginRequest
     */
    readonly loginRequest: LoginRequest
}

/**
 * Request parameters for signupUser operation in UsersApi.
 */
export interface UsersApiSignupUserRequest {
    readonly signupUserRequest?: SignupUserRequest
}

/**
 * UsersApi - object-oriented interface
 */
export class UsersApi extends BaseAPI {
    /**
     * Автоматически регистрирует пользователя в системе без подтверждения регистрации через email. Для работы метода необходимо получить специальные права доступа в службе поддержки.
     * @summary Авторегистрация пользователя
     * @param {UsersApiAutoSignupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public autoSignupUser(requestParameters: UsersApiAutoSignupUserRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).autoSignupUser(requestParameters.signupUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Авторизует пользователя и выдает ему токен для доступа к API
     * @summary Авторизация пользователя. Получение токена к API
     * @param {UsersApiLoginUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginUser(requestParameters: UsersApiLoginUserRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).loginUser(requestParameters.loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Регистрирует пользователя в системе. Для завершения регистрации на email придет письмо с подтверждением.
     * @summary Регистрация пользователя
     * @param {UsersApiSignupUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public signupUser(requestParameters: UsersApiSignupUserRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).signupUser(requestParameters.signupUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebhooksApi - axios parameter creator
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Список зарегистрированных подписок
         * @summary Список зарегистрированных подписок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Подписка на событие выбранного типа. Подробнее о типах и формате запроса с нашей стороны читайте здесь: https://docs.apiship.ru/docs/api/webhooks
         * @summary Подписка на вебхуки
         * @param {WebhookSubscribeRequest} webhookSubscribeRequest Объект типа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost: async (webhookSubscribeRequest: WebhookSubscribeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webhookSubscribeRequest' is not null or undefined
            assertParamExists('webhooksPost', 'webhookSubscribeRequest', webhookSubscribeRequest)
            const localVarPath = `/webhooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webhookSubscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Удаление подписки на событие
         * @summary Удаление вебхука
         * @param {string} uuid Уникальный идентификатор подписки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUuidDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('webhooksUuidDelete', 'uuid', uuid)
            const localVarPath = `/webhooks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Список зарегистрированных подписок
         * @summary Список зарегистрированных подписок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebhookListResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Подписка на событие выбранного типа. Подробнее о типах и формате запроса с нашей стороны читайте здесь: https://docs.apiship.ru/docs/api/webhooks
         * @summary Подписка на вебхуки
         * @param {WebhookSubscribeRequest} webhookSubscribeRequest Объект типа
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksPost(webhookSubscribeRequest: WebhookSubscribeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscribeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksPost(webhookSubscribeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Удаление подписки на событие
         * @summary Удаление вебхука
         * @param {string} uuid Уникальный идентификатор подписки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksUuidDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebhookSubscriptionDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksUuidDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebhooksApi.webhooksUuidDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebhooksApi - factory interface
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Список зарегистрированных подписок
         * @summary Список зарегистрированных подписок
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebhookListResponseInner>> {
            return localVarFp.webhooksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Подписка на событие выбранного типа. Подробнее о типах и формате запроса с нашей стороны читайте здесь: https://docs.apiship.ru/docs/api/webhooks
         * @summary Подписка на вебхуки
         * @param {WebhooksApiWebhooksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksPost(requestParameters: WebhooksApiWebhooksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscribeResponse> {
            return localVarFp.webhooksPost(requestParameters.webhookSubscribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Удаление подписки на событие
         * @summary Удаление вебхука
         * @param {WebhooksApiWebhooksUuidDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksUuidDelete(requestParameters: WebhooksApiWebhooksUuidDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<WebhookSubscriptionDeleteResponse> {
            return localVarFp.webhooksUuidDelete(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for webhooksPost operation in WebhooksApi.
 */
export interface WebhooksApiWebhooksPostRequest {
    /**
     * Объект типа
     */
    readonly webhookSubscribeRequest: WebhookSubscribeRequest
}

/**
 * Request parameters for webhooksUuidDelete operation in WebhooksApi.
 */
export interface WebhooksApiWebhooksUuidDeleteRequest {
    /**
     * Уникальный идентификатор подписки
     */
    readonly uuid: string
}

/**
 * WebhooksApi - object-oriented interface
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Список зарегистрированных подписок
     * @summary Список зарегистрированных подписок
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksGet(options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Подписка на событие выбранного типа. Подробнее о типах и формате запроса с нашей стороны читайте здесь: https://docs.apiship.ru/docs/api/webhooks
     * @summary Подписка на вебхуки
     * @param {WebhooksApiWebhooksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksPost(requestParameters: WebhooksApiWebhooksPostRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksPost(requestParameters.webhookSubscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Удаление подписки на событие
     * @summary Удаление вебхука
     * @param {WebhooksApiWebhooksUuidDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public webhooksUuidDelete(requestParameters: WebhooksApiWebhooksUuidDeleteRequest, options?: RawAxiosRequestConfig) {
        return WebhooksApiFp(this.configuration).webhooksUuidDelete(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * X5Api - axios parameter creator
 */
export const X5ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Создание склада
         * @summary Создание склада
         * @param {CreateWarehouseRequest} [createWarehouseRequest] Объект типа CreateWarehouseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse: async (createWarehouseRequest?: CreateWarehouseRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/x5/createWarehouse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWarehouseRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * X5Api - functional programming interface
 */
export const X5ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = X5ApiAxiosParamCreator(configuration)
    return {
        /**
         * Создание склада
         * @summary Создание склада
         * @param {CreateWarehouseRequest} [createWarehouseRequest] Объект типа CreateWarehouseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWarehouse(createWarehouseRequest?: CreateWarehouseRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWarehouseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWarehouse(createWarehouseRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['X5Api.createWarehouse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * X5Api - factory interface
 */
export const X5ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = X5ApiFp(configuration)
    return {
        /**
         * Создание склада
         * @summary Создание склада
         * @param {X5ApiCreateWarehouseRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWarehouse(requestParameters: X5ApiCreateWarehouseRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CreateWarehouseResponse> {
            return localVarFp.createWarehouse(requestParameters.createWarehouseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createWarehouse operation in X5Api.
 */
export interface X5ApiCreateWarehouseRequest {
    /**
     * Объект типа CreateWarehouseRequest
     */
    readonly createWarehouseRequest?: CreateWarehouseRequest
}

/**
 * X5Api - object-oriented interface
 */
export class X5Api extends BaseAPI {
    /**
     * Создание склада
     * @summary Создание склада
     * @param {X5ApiCreateWarehouseRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createWarehouse(requestParameters: X5ApiCreateWarehouseRequest = {}, options?: RawAxiosRequestConfig) {
        return X5ApiFp(this.configuration).createWarehouse(requestParameters.createWarehouseRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * YataxiApi - axios parameter creator
 */
export const YataxiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Подтверждение заказа
         * @summary Подтверждение заказа
         * @param {ConfirmOrderYataxiRequest} [confirmOrderYataxiRequest] Объект типа ConfirmOrderYataxi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrderYataxi: async (confirmOrderYataxiRequest?: ConfirmOrderYataxiRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/yataxi/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmOrderYataxiRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * YataxiApi - functional programming interface
 */
export const YataxiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = YataxiApiAxiosParamCreator(configuration)
    return {
        /**
         * Подтверждение заказа
         * @summary Подтверждение заказа
         * @param {ConfirmOrderYataxiRequest} [confirmOrderYataxiRequest] Объект типа ConfirmOrderYataxi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmOrderYataxi(confirmOrderYataxiRequest?: ConfirmOrderYataxiRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmOrderYataxiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmOrderYataxi(confirmOrderYataxiRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['YataxiApi.confirmOrderYataxi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * YataxiApi - factory interface
 */
export const YataxiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = YataxiApiFp(configuration)
    return {
        /**
         * Подтверждение заказа
         * @summary Подтверждение заказа
         * @param {YataxiApiConfirmOrderYataxiRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmOrderYataxi(requestParameters: YataxiApiConfirmOrderYataxiRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ConfirmOrderYataxiResponse> {
            return localVarFp.confirmOrderYataxi(requestParameters.confirmOrderYataxiRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for confirmOrderYataxi operation in YataxiApi.
 */
export interface YataxiApiConfirmOrderYataxiRequest {
    /**
     * Объект типа ConfirmOrderYataxi
     */
    readonly confirmOrderYataxiRequest?: ConfirmOrderYataxiRequest
}

/**
 * YataxiApi - object-oriented interface
 */
export class YataxiApi extends BaseAPI {
    /**
     * Подтверждение заказа
     * @summary Подтверждение заказа
     * @param {YataxiApiConfirmOrderYataxiRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public confirmOrderYataxi(requestParameters: YataxiApiConfirmOrderYataxiRequest = {}, options?: RawAxiosRequestConfig) {
        return YataxiApiFp(this.configuration).confirmOrderYataxi(requestParameters.confirmOrderYataxiRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



